\documentclass[twoside]{projektMagisterski}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{amsmath}
\usepackage{xcolor}

\definecolor{red}{rgb}{0.95,0,0}

%\drukJednostronny

%% tytu³ promotor i autor (\title to komenda standardowa)
\title{Analiza porównawcza algorytmów metaheurystycznych do rozwi¹zywania wybranego problemu optymalizacyjnego}
\promotor{dr in¿. Henryk Josiñski}


%% ka¿dy autor musi mieæ 3 argumenty: imiê nazwisko, nr albumu, opis wk³adu
\autor{Sebastian Nalepka}{111111}
	


%\NumeryNaPoczatku
%% numeracja wzorów tu w³¹czona typu (1.2.3), ta druga to typu (1.2), domyœlnie typu (1)
%\subsectionWzory
% \sectionWzory  

%\rozdzialy


%\literowaNumeracjaDodatkow %% w³¹czy numeracjê dodatków literami
%\rzymskaNumeracjaDodatkow  %%w³¹czy numeracjê dodatków liczbami rzymskimi

%% wy³¹czenie wyjaœnieñ:
\bezWyjasnien

%% standardowe komendy \newtheorem  dzia³aj¹ jak woryginale
\newtheorem{tw}{Twierdzenie}%[subsection]
\newtheorem{twa}{Twierdzenie}%[section]
\newtheorem{dd}{Definicja}%[subsection]

\begin{document}

W otaczaj¹cym nas œwiecie obecnych jest wiele problemów, z którymi zmagaj¹ siê ludzie. Czêœæ z nich jest problemami prostymi, do rozwi¹zania których wystarczy wy³¹cznie niedu¿y nak³ad czasu. Istniej¹ jednak problemy trudniejsze, które wymagaj¹ d³ugotrwa³ych przemyœleñ i obliczeñ po których nie zawsze otrzymujemy najlepsze rozwi¹zanie. Do prostych problemów mo¿emy zaliczyæ codzienne decyzje podejmowane przez ka¿dego cz³owieka dotycz¹ce. Dla przyk³adu jeœli chcemy dojechaæ z punktu A do punktu B komunikacj¹ miejsk¹, wystarczy, ¿e sprawdzimy rozk³ad jazdy i wybierzemy po³¹czenie, które bêdzie pasowa³o nam w kontekœcie godziny przyjazdu na dane miejsce. Przedstawiony problem posiada z go³a inn¹ skalê trudnoœci ze strony przewoŸnika. Wyznaczenie optymalnych tras przewozowych dla okreœlonej liczby œrodków transportu, w celu obs³u¿enia danego zbioru klientów, którzy rozlokowani s¹ w ró¿nych punktach jest kwesti¹ bardzo skomplikowan¹. Znalezienie optymalnych tras, które umo¿liwi¹ przetransportowanie jak najwiêkszej iloœci osób w celu zmaksymalizowania zysku, przy zachowaniu mo¿liwie najkrótszych tras, których zamys³em jest minimalizowanie kosztów poniesionych z transportem jest z³o¿onym problemem, znanym jako jedna z odmian problemu marszrutyzacji, który jest z kolei rozwiniêciem bardzo popularnego problemu komiwoja¿era polegaj¹cego na znalezieniu najkrótszej drogi ³¹cz¹cej wszystkie zdefiniowane uprzednio punkty, zaczynaj¹c i koñcz¹c w tym samym miejscu. Problemy, do rozwi¹zania których potrzebne s¹ ogromne nak³ady obliczeniowe definiowane s¹ jako  problemy optymalizacyjne. W problemach takich liczba mo¿liwych rozwi¹zañ w przestrzeni poszukiwañ z regu³y jest tak du¿a, ¿e niemo¿liwe jest przeszukiwanie wyczerpuj¹ce w celu znalezienia najlepszego z nich. 

\subsection*{Cel pracy}

Celem pracy jest dokonanie analizy porównawczej algorytmu symulowanego wy¿arzania, algorytmu genetycznego oraz roju cz¹stek, która przeprowadzona bêdzie dziêki zaimplementowanej dedykowanej aplikacji bazodanowej, której przeznaczeniem jest zautomatyzowanie procesu szukania minimum globalnego zadanych dla funkcji testowych.

\subsection*{Zawartoœæ pracy}

Dla osi¹gniêcia wy¿ej wymienionego celu zrealizowana zosta³a praca sk³adaj¹ca siê z siedmiu rozdzia³ów oraz wniosków przeprowadzonych doœwiadczeñ wraz z podsumowaniem. W rozdziale pierwszym przedstawiony zosta³ wybór problemu optymalizacyjnego wraz z jego opisem oraz list¹ funkcji testowych, które u¿yte zosta³y do przeprowadzenia badañ. Rozdzia³ drugi przedstawia mo¿liwe sposoby rozwi¹zania wybranego problemu optymalizacyjnego wraz z opisem u¿ytych algorytmów metaheurystycznych. Na bazie dwóch pierwszych rozdzia³ów utworzony zosta³ w rozdziale trzecim projekt automatyzacji przeprowadzanych doœwiadczeñ, na podstawie którego bazowa³a budowana aplikacja. Kolejny rozdzia³ to zastosowane rozwi¹zania technologiczne oraz opis wykorzystanych technologii, bibliotek zewnêtrznych, a tak¿e narzêdzi. Na ich podstawie utworzona zosta³a architektura aplikacji bazodanowej, której specyfikacja umiejscowiona zosta³a w rozdziale pi¹tym. Kolejny rozdzia³ prezentuje ju¿ œciœle aspekt badawczy, który zawiera  opis metod porównawczych zastosowanych algorytmów oraz wyniki doœwiadczeñ dla u¿ytych funkcji testowych, których analiza przeprowadzona zosta³a w rozdziale siódmym zawieraj¹cym wnioski.

\section{Wybór badanego problemu optymalizacji}

\subsection{Opis minimalizacji funkcji ci¹g³ych wielu zmiennych}

W prezentowanej pracy dokonano porównania algorytmów metaheurystycznych odnosz¹c siê do problemu minimalizacji funkcji wielu zmiennych. Problem ten polega na znalezieniu minimum globalnego rzeczywistej funkcji poprzez systematyczne wybieranie parametrów wejœciowych z dozwolonego zakresu i obliczaniu ich wartoœci. Trudnoœæ problemu sprowadza siê do wielkoœci przestrzeni przeszukiwania. Traktuj¹c problem jako czysto matematyczny, funkcja n zmiennych posiada nieskoñczenie wiele wartoœci w ka¿dym wymiarze. Mamy wiêc nieskoñczenie wielk¹ przestrzeñ poszukiwañ. Bior¹c jednak pod wzgl¹d aspekt technologiczny i to, i¿ komputery bazuj¹ na danych skoñczonych, mo¿na w prosty sposób przedstawiæ skalê trudnoœci. W czasie implementacji algorytmu, którego celem jest znalezienie minimum globalnego funkcji, nale¿y wzi¹æ pod uwagê dostêpn¹ dok³adnoœæ obliczeniow¹ maszyny. Zak³adaj¹c, i¿ dok³adnoœæ ta wynosi osiem miejsc po przecinku, ka¿da zmienna, ograniczona w przedziale $[0,100]$ mo¿e przyj¹æ $100*10^8$  ró¿nych wartoœci. Ju¿ dla funkcji dwóch zmiennych, wielkoœæ przestrzeni przeszukiwania wynosi $(100*10^8)^2 = 10^{20} $.

\subsection{Funkcje testowe}

Problem minimalizacji funkcji ci¹g³ych bardzo dobrze nadaje siê do porównania algorytmów metaheurystycznych przez wzgl¹d na powszechnie dostêpne funkcje testowe. Funkcje te, posiadaj¹ pewny specyficzny element, dziêki któremu mo¿liwe jest porównanie wyników otrzymanych przez dany algorytm. Element ten to znajomoœæ minimum globalnego dla danej funkcji testowej. Dziêki znajomoœci wartoœci najlepszej (najmniejszej) dla danej funkcji, wiadomo jak szybko oraz czy w ogóle badany algorytm znalaz³ rozwi¹zanie. Posiadaj¹c t¹ informacjê mo¿na zestawiæ otrzymane rezultaty wszystkich algorytmów pod k¹tem czasowym lub liczby wyliczeñ wartoœci funkcji dla ustalonych przez algorytm punktów.
Do analizy wybranych zosta³o piêæ funkcji testowych, których dobór bra³ pod uwagê stopieñ ich skomplikowania. Ka¿da z funkcji posiada specyficzne w³aœciwoœci, które zostan¹ wziête pod uwagê podczas porównania rezultatów algorytmów heurystycznych.

\subsubsection{Funkcja Bochachevsky’ego N. 1}
\subsubsection{Funkcja Rosenbrocka}
\subsubsection{Funkcja Easoma}
\subsubsection{Funkcja Eggholdera}
\subsubsection{Funkcje Griewanka}
\subsubsection{Funkcje testowe}

\textcolor{brown}{Opis funkcji wraz z ich w³aœciwoœciami opisaæ po definitywnym ich wyborze (poczekaæ na fazê testów)}

\section{Metody rozwi¹zania wybranego problemu optymalizacji}

\subsection{Algorytmy dok³adne}

Klasycznym podejœciem do znalezienia minimalnej wartoœci zadanej funkcji testowej jest próba porównania wartoœci funkcji dla ka¿dych mo¿liwych parametrów wejœciowych i wybrania w ten sposób optymalnego rozwi¹zania. W rzeczywistoœci jednak takie rozwi¹zanie nie jest praktyczne przez wzgl¹d na olbrzymi¹ mo¿liw¹ liczbê takich parametrów. Jak ju¿ wspomniano w rozdziale 1.1  liczba rozwi¹zañ dla funkcji ograniczonej ju¿ do dwóch zmiennych mo¿e wynieœæ $10^{20}$, a w przypadku trzech zmiennych – $10^{30}$. Zak³adaj¹c, i¿ mo¿liwe by by³o wyliczenie miliarda wartoœci funkcji na sekundê, to w godzinê wartoœæ ta wynosi³aby  $3.6*10^{12}$, a w rok – $3.2*10^{16}$. Prowadz¹c dalej obliczenia wychodzi, i¿ wyliczenie $10^{20}$ wartoœci funkcji trwa³oby oko³o 3125 lat. Widaæ, i¿ liczba kombinacji jest tak du¿a, i¿ takie podejœcie jest niemo¿liwe do wykonania w akceptowalnym czasie.

\subsection{Metaheurystyki optymalizacyjne}

Analizuj¹c podejœcie z rozdzia³u 2.1, mo¿e przyjœæ na myœl sposób, który polegaæ bêdzie na wyliczaniu wartoœci funkcji dla wyrywkowych parametrów. Sk¹d jednak wiadomo które punkty wybraæ? Na podstawie czego bazowaæ? W przypadku problemów, w których przez wzgl¹d na czas niemo¿liwe jest dojœcie do rozwi¹zania na ratunek przychodz¹ algorytmy heurystyczne, które umo¿liwiaj¹ skrócenie czasu obliczeñ. Cen¹ któr¹ trzeba jednak za to zap³aciæ jest otrzymanie potencjalnie gorszego rozwi¹zania od rozwi¹zania najlepszego. Samo pojêcie heurystyki pochodzi od greckiego s³owa heuresis, które znaczy ‘odnaleŸæ’. Metody heurystyczne polegaj¹ na u¿yciu regu³ oraz faktów, które uzyskane na drodze badania danego problemu, umo¿liwiaj¹ jego rozwi¹zanie lub zbli¿enie siê do poprawnej odpowiedzi. Podejœcie heurystyczne stosowane mo¿e byæ w sposób piêtrowy, tworz¹c metaheurystyki. Metaheurystyka jest to ogólny algorytm do rozwi¹zywania problemów obliczeniowych, który inspiracjê czêsto bierze z mechanizmów biologicznych lub fizycznych. Okreœlenie to oznacza tak zwan¹ heurystykê wy¿szego poziomu, co wynika z faktu, i¿ algorytmy tego typu bezpoœrednio nie rozwi¹zuj¹ ¿adnego problemu, a wy³¹cznie podaj¹ metodê na utworzenie odpowiedniego algorytmu. 


\subsubsection{Metoda optymalizacji rojem cz¹stek}

Metoda roju cz¹stek (PSO – Particle Swarm Optimization) jest przyk³adem optymalizacji z kategorii metod inteligencji stadnej. Powsta³a ona w wyniku inspiracji biologicznej, której Ÿród³em by³ uk³ad lotu stada ptaków tworzony w celu znalezienia po¿ywienia lub gniazda oraz unikniêcia drapie¿ników. Zastosowanie prostych zasad umo¿liwia ptakom zsynchronizowany oraz bezkolizyjnych ruch, który daje efekt zachowania jednego organizmu. Ruch stada ptaków, czy ³awicy ryb jest wypadkow¹ dzia³ania wszystkich osobników i koncentruje siê na utrzymaniu optymalnego dystansu od swoich s¹siadów, przy jednoczesnym pod¹¿aniem za liderem. Badania nad optymalizacj¹ roju cz¹stek zapocz¹tkowano od próby graficznego zasymulowania zachowañ takich grup. Bardzo szybko okaza³o siê, i¿ stworzony matematyczny model mo¿e byæ równie¿ zastosowany jako metoda optymalizacyjna.
W optymalizacji rojem cz¹stek rozwi¹zania (cz¹stki) wspó³pracuj¹ ze sob¹ w celu odnalezienia cz¹stki optymalnej. W czasie procesu optymalizacji nastêpuje zmiana po³o¿enia ka¿dej cz¹stki w przestrzeni rozwi¹zañ poprzez wyznaczenie wektora prêdkoœci. Wektor ten jest modyfikowany przy u¿yciu informacjê o historii poszukiwañ danej cz¹stki oraz jej cz¹stek s¹siednich. Metoda PSO w problemie optymalizacji funkcji wielowymiarowych d¹¿y do otrzymania cz¹steczki, która reprezentuje jak najmniejsz¹ wartoœæ funkcji i mo¿e byæ opisana dwoma równaniami:

\begin{equation}
v=W*v+c_1*r_1*(p-x)+c_2*r_2*(g-x)
\end{equation}
gdzie,

$v$ - aktualny wektor prêdkoœci cz¹stki

$W$ – parametr z zakresu $[0,1]$, który determinuje wp³yw poprzedniego po³o¿enia cz¹stki na jej obecn¹ pozycjê

$p$ - najlepsze rozwi¹zanie dla cz¹stki

$g$ – najlepsze rozwi¹zanie dla s¹siedztwa cz¹stek

$r_1,r_2$ – losowe liczby z zakresu $[0,1]$

$c_1,c_2$ – parametry skaluj¹ce z zakresu $[0,1]$

Nawi¹zuj¹c do powy¿szych równañ, ka¿da cz¹stka roju przeszukuje przestrzeñ rozwi¹zañ, zmieniaj¹c po³o¿enie na podstawie swoich najlepszych rozwi¹zañ $p_i$, jednoczeœnie wykorzystuj¹c informacjê o najlepszym rozwi¹zaniu w s¹siedztwie $p_t$. Parametry skaluj¹ce umo¿liwiaj¹ kontrolê wp³ywu danych czêœci wektora prêdkoœci na wynik. W przypadku, w którym $c_1$ bêdzie równe zero, cz¹stka bêdzie wykorzystywa³a tylko i wy³¹cznie informacjê o najlepszym rozwi¹zaniu w roju. Z kolei jeœli wartoœæ parametru $c_2$ zostanie ustawiona na zero, cz¹stka bêdzie poszukiwa³a rozwi¹zania samodzielnie, bez uwzglêdnienia rozwi¹zañ, które uzyskane zosta³y przez inne cz¹stki. 

\subsubsection{Symulowane wy¿arzanie}

Algorytm symulowanego wy¿arzania po raz pierwszy zosta³ opisany w 1953 roku przez Nicolasa Metropolisa. Sposób dzia³ania algorytmu jak i równie¿ jego nazwa odnosi siê do procesów fizycznych, które wykorzystywane s¹ w metalurgii. Proces wy¿arzania polega na rozgrzaniu cia³a sta³ego do okreœlonej temperatury, a nastêpnie jego powolnym studzeniu. Konsekwencj¹ tego dzia³ania jest zmiana struktury krystalicznej materia³u, który poddany zosta³ wy¿arzaniu. W czasie procesu och³adzania metali dostrze¿ono, i¿ cz¹steczki cia³a
wraz z jego powolnym sch³adzaniem tworz¹ bardziej regularne struktury, ni¿ w przypadku szybszego obni¿enia temperatury, kiedy to ch³odzone cz¹steczki nie potrafi¹ znaleŸæ optymalnego po³o¿enia.
Algorytm symulowanego wy¿arzania jest usprawnieniem starszych metod iteracyjnych, które polega³y na ci¹g³ym ulepszaniu istniej¹cego rozwi¹zania do momentu braku mo¿liwoœci jego poprawy. W metodach tych zatrzymanie algorytmu mog³o nast¹piæ przy rozwi¹zaniu pseudo-optymalnym – lokalnym minimum. Nie istnia³a wówczas mo¿liwoœæ wyjœcia z owego lokalnego minima i kierowania siê w kierunku minimum globalnego. Bardzo wa¿n¹ cech¹ opisywanego algorytmu jest mo¿liwoœæ wyboru, z pewnym prawdopodobieñstwem, gorszego rozwi¹zania. Dziêki temu problem utkniêcia w lokalnym minimum nie jest ju¿ groŸny. Za wybór gorszego rozwi¹zania ma wp³yw podstawowy parametr przeniesiony z podstaw termodynamicznych algorytmu – temperatura. Im jest ona wy¿sza, tym wiêksze istnieje prawdopodobieñstwo wyboru i zaakceptowania gorszego rozwi¹zania. W czasie dzia³ania algorytmu, temperatura obni¿a siê i dzia³anie algorytu zbli¿a siê w ten sposób do typowych metod iteracyjnych.
W celu wykonania algorytmu symulowanego wy¿arzania w kontekœcie optymalizacji funkcji wielu zmiennych nale¿y na pocz¹tku losowo wygenerowaæ punkt startowy, który mieœci siê na p³aszczyŸnie poszukiwañ, wyliczyæ dla niego wartoœæ funkcji oraz wybraæ maksymaln¹ temperaturê startow¹ z dostêpnego zakresu [0,100]. Ka¿da iteracja polega na wyborze losowego rozwi¹zania z s¹siedztwa, wyliczenia dla niego wartoœci funkcji i porównaniu z obecnie najlepszym rezultatem oraz obni¿eniu temperatury. W przypadku, w którym wartoœæ funkcji nowego punktu jest mniejsza (lepsza), jest on zaklasyfikowany jako najlepszy. W przeciwnej sytuacji punkt nie jest natychmiastowo odrzucany. Algorytm akceptuje gorsze rezultaty bazuj¹c na funkcji akceptacyjnej, która prezentuje siê nastêpuj¹co:

\begin{equation}
\frac{1}{1+exp(\frac{\Delta}{max(T)})}
\end{equation}
gdzie,

$\Delta$ – ró¿nica wartoœci starego i nowego punktu

$T$ – wartoœæ temperatury

W sytuacji, w której $\Delta$ i $T$ s¹ wartoœciami dodatnimi, prawdopodobieñstwo akceptacji mieœci siê pomiêdzy 0 i $\frac{1}{2}$. Ni¿sza temperatura prowadzi do mniejszego prawdopodobieñstwa zaakceptowania gorszego rezultatu. Podobnie jest z delt¹ – im wiêksza delta tym mniejsza szansa na zaakceptowanie.

\subsubsection{Algorytm genetyczny}

Model algorytmu genetycznego po raz pierwszy zaprezentowany zosta³ w 1975 roku przez Johna Hollanda, który w pracy „Adaptation in Natural and Artifical Systems” przedstawi³ fundamenty za³o¿eñ dotycz¹cych adaptacji darwinowskiej teorii ewolucji w systemach informatycznych.  
W opisie algorytmu genetycznego pos³uguje siê powszechn¹ terminologi¹ biologiczn¹. Z tego te¿ powodu mówi siê, i¿ algorytmy genetyczne przetwarzaj¹ populacjê osobników, którzy reprezentuj¹ rozwi¹zanie danego problemu. Ka¿dy element populacji nazywany jest chromosomem, a jego sk³adowe genami. Allele z kolei, s¹ to mo¿liwe stany (wartoœci) genu, które umiejscowione s¹ na pozycjach zdefiniowanych jako locus. W badanych modelach komputerowych, osobniki (chromosomy) mog¹ byæ opisane jako ró¿ne struktury – zaczynaj¹c na ³añcuchach binarnych, a koñcz¹c na bardzo z³o¿onych obiektach. W okreœlonej iteracji zwanej zamiennie pokoleniem albo generacj¹, dane chromosomy na bazie okreœlonej miary ich dostrojenia podlegaj¹ ocenie. Ocena ta skutkuje wyborem najlepiej przystosowanych osobników, które wezm¹ udzia³ w kolejnych iteracjach algorytmu. Nim jednak wybrane osobniki populacji utworz¹ now¹ generacjê, zostaj¹ poddane modyfikacjom spowodowanym podstawowymi operacjami genetycznymi – krzy¿owaniem, selekcj¹ oraz mutacj¹.
W kontekœcie problemu optymalizacji funkcji wielu zmiennych, inicjalizacja algorytmu genetycznego polega na wygenerowaniu populacji pocz¹tkowej, która z³o¿ona jest z okreœlonej liczby chromosomów. Ka¿dy chromosom reprezentowany w populacji posiada tak¹ sam¹ d³ugoœæ, która ustalona jest zale¿nie od rozwi¹zywanego problemu na etapie implementowania algorytmu. Przed nast¹pieniem etapu generowania musi byæ jednak okreœlony sposób kodowania informacji zawartej w chromosomie, która dotyczy rozwi¹zania. W algorytmie Hollanda nie by³o domyœlnie zdefiniowanego sposobu kodowania chromosomów. Powszechnie uznaje siê jednak, i¿ w algorytmie genetycznym stosuje siê kodowanie binarne. Takie te¿ kodowanie jest zastosowane w kontekœcie omawianego problemu optymalizowania funkcji wielu zmiennych. Kolejnym etapem, który nastêpuje po wygenerowaniu populacji pocz¹tkowej oraz wyborze kodowania chromosomów jest wyznaczenie jakoœci chromosomów danej populacji. W tym celu obliczana jest wartoœæ tak zwanej funkcji oceny, która definiuje poziom dopasowania konkretnego chromosomu. Tym sposobem mo¿na stwierdziæ, które chromosomy lepiej rozwi¹zuj¹ dane zagadnienie, a które gorzej. Znalezienie rozwi¹zania danego problemu sprowadza siê do znalezienia ekstremum wspomnianej funkcji oceny. Kolejn¹ czêœci¹ algorytmu jest zastosowanie mechanizmu selekcji, który definiuje sposób wyboru rozwi¹zañ rodzicielskich, z których tworzone bêd¹ tak zwane rozwi¹zania potomne u¿yte w nastêpnej generacji. Podstawowy algorytm genetyczny w operacji selekcji stosuje metodê ruletki. Metoda ta polega na przydzieleniu ka¿demu chromosomowi z danej populacji prawdopodobieñstwa wed³ug wzoru:

\begin{equation}
p_i = \frac{f_i}{\sum_{j=1}^{N}f_j}
\end{equation}

gdzie,
$f_i$ - wartoœæ funkcji oceny chromosomu i-tego
$p_i$ – prawdopodobieñstwo reprodukcji

W celu wybrania puli rodzicielskiej, ko³o ruletki o obwodzie jeden dzielone jest na czêœci o d³ugoœci $p_i$, a nastêpnie z zakresu $[0,1]$ losowana jest liczba, która jednoznacznie identyfikuje punkt na ruletce, a co za tym idzie konkretny chromosom. Chromosom ten brany bêdzie pod uwagê w procesie nastêpnej reprodukcji, a losowanie powtarzane jest tak d³ugo, a¿ wylosowana zostanie ustalona liczba chromosomów. W problemie minimalizacji funkcji wielu zmiennych istnieje mo¿liwoœæ, i¿ wartoœæ funkcji oceny bêdzie ujemna. W celu zniwelowania problemu ujemnego prawdopodobieñstwa powy¿szy wzór zosta³ zmodyfikowany stosuj¹c skalowanie przystosowania:

\begin{equation}
p_i = \frac{f_i-f_{min}}{\sum_{j=1}^{N}f_j-f_{min}}
\end{equation} 

gdzie $f_{min}$ jest wartoœci¹ funkcji przystosowania najgorszego chromosomu. \newline
 
Po etapie selekcji pozostaje do zdefiniowania kwestia wymiany pokoleñ. W implementacjach czêsto stosowana jest metoda ca³kowitego zastêpowania, w której ca³a aktualna populacja, podlega operacjom krzy¿owania i mutacji. Innym sposobem jest metoda zastêpowania czêœciowego, w której czêœæ najlepszych chromosomów obecnej populacji przechodzi do populacji potomnej be¿ ¿adnych zmian, a pozosta³e elementy z kolei bior¹ udzia³ w operacji krzy¿owania i mutacji. Czêsto stosowan¹ praktyk¹ jest zastosowanie zastêpowana elitarnego, w którym na podstawie parametru okreœlaj¹cego wielkoœæ elity, czêœæ najlepszych osobników jest kopiowana do nowej generacji ju¿ na samym pocz¹tku. Umo¿liwia to ‘pamiêtanie’ najlepszych chromosomów które mog³y byæ zmienione poprzez dzia³anie operatorów genetycznych.

Pierwszym z takich operatorów jest krzy¿owanie, które jest operacj¹ umo¿liwiaj¹c¹ tworzenie nowych rozwi¹zañ. Jego koncept bazuje na procesie rozmna¿ania organizmów, w czasie trwania których dziecko dziedziczy czêœæ genów rodziców. W kontekœcie omawianego algorytmu genetycznego, krzy¿owanie polega na przeciêciu chromosomów w ustalonym punkcie i ich wzajemnego zamienienia. 
Drugim operatorem genetycznym jest mutacja, która umo¿liwia wprowadzenie nowego elementu do populacji poprzez tworzenie ró¿norodnoœci. Analogicznie jak w otaczaj¹cym nas œwiecie, tak i w algorytmie genetycznym, mutacje zdarzaj¹ siê rzadko. Ich skala zazwyczaj zale¿y od parametru, który przyjmuje niskie wartoœci. W odniesieniu do chromosomów w postaci binarnej, mutacja mo¿e polegaæ na losowej zamianie losowego genu na wartoœæ przeciwn¹. Tak utworzona nowa generacja ponownie przechodzi przez wszystkie punkty algorytmu. Dzieje siê tak a¿ do czasu, w którym spe³nione zostan¹ warunki zatrzymania, które w kontekœcie przedstawianego zagadnienia opisane zosta³y w rozdziale 6.1 opisuj¹cym metody porównawcze wybranych algorytmów obejmuj¹ce w swojej treœci warunki stopu opisanych trzech metaheurystyków.

\section{Automatyzacja przeprowadzanych badañ}

Porównanie algorytmów metaheurystycznych w odniesieniu do problemu minimalizacji funkcji wielu zmiennych jest zadaniem bardzo skomplikowanym przez fakt iloœci doœwiadczeñ, które trzeba wykonaæ. Badania porównawcze przeprowadzane bêd¹ pod k¹tem kilku parametrów. Dla ka¿dego z nich nale¿y przeprowadziæ wielokrotne testy dla ka¿dego testowanego algorytmu. Ustalaj¹c próbkê testu na poziomie $10^4$ prób, z której bêdzie obliczana wartoœæ œrednia oraz bior¹c pod uwagê dwa parametry porównawcze, z których ka¿dy przyjmowaæ mo¿e dla przyk³adu dziesiêæ wartoœci, liczba testów dla jednego algorytmu oraz jednej funkcji testowej osi¹ga ju¿ wartoœæ $2*10^5$. Manualne przetwarzanie w œrodowisku Matlab przy ograniczonej funkcjonalnoœci agregowania wyników jest bardzo czasoch³onnym zadaniem. W tym celu zdecydowano siê zbudowaæ dedykowan¹ aplikacjê bazodanow¹, która bêdzie umo¿liwia³a automatyzacjê przedstawianej operacji. U¿ytkownik z poziomu aplikacji bêdzie mia³ mo¿liwoœæ wyboru funkcji testowej, algorytmu heurystycznego oraz jego parametrów a tak¿e liczby testów, która ma byæ przeprowadzona przy zadanych wartoœciach. Aplikacja automatycznie bêdzie wysy³a³a zapytania do œrodowiska obliczeniowego Matlab, obiera³a wyniki oraz umieszcza³a je w bazie danych, z której w prosty i efektywny sposób mo¿na bêdzie przeprowadziæ ich agregacjê w celu przedstawienia wyników i ich porównania. W ten sposób narzut pracy, który niezbêdny jest do implementacji przedstawionej aplikacji z ca³¹ pewnoœci¹ siê zwróci oraz umo¿liwi dalsz¹ analizê algorytmów w kontekœcie problemu funkcji wielu zmiennych poniewa¿ aplikacja napisana zostanie w sposób umo¿liwiaj¹cy proste dodanie kolejnych algorytmów funkcji testowych.

\section{Wykorzystane rozwi¹zania technologiczne}

\subsection{Zastosowane technologie}

Obecny rozdzia³ obejmuje opis wykorzystanych technologii, które umo¿liwi³y implementacjê aplikacji. Opis ten dotyczy jêzyka programowania, w którym napisany zosta³ backend aplikacji oraz silnika graficznego aplikacji wraz z jêzykiem zapytañ bazy danych.

\subsubsection{.NET Framework/C\#}

.NET Framework jest to platforma programistyczna wydana przez firmê Microsoft w 2002 roku. Przeznaczona ona jest do wytwarzania oprogramowania przeznaczonego dla systemów operacyjnych z rodziny Windows. G³ówn¹ sk³adow¹ przedstawianej platformy s¹ kompilatory jêzyków wysokiego poziomu, które umo¿liwiaj¹ przeprowadzenie operacji kompilacji programów napisanych w jêzykach Visual Basic, F\#, C++/CLI. Platforma .NET wspiera równie¿ jeden z najpopularniejszych jêzyków programowania na œwiecie - C\#, w którym napisana zosta³a aplikacja odnosz¹ca siê do prezentowanej pracy magisterskiej. Wed³ug rankingu TIOBE Software z grudnia 2015 roku, jêzyk C\# uplasowany jest na pi¹tym miejscu, spoœród piêædziesiêciu najpopularniejszych jêzyków, które zosta³y wziête pod uwagê.
C\# jest to nowoczesny, zorientowany obiektowo jêzyk programowania stworzony przez firmê Microsoft. Jego pierwsza wersja wydana zosta³a ju¿ w po³owie 2000 roku, przy du¿ej zas³udze g³ównego projektanta jêzyka - duñskiego in¿yniera oprogramowania Andersa Hejlsberga. Jêzyk ten mo¿e zostaæ u¿yty w celu pisania aplikacji webowych, desktopowych oraz przeznaczonych na urz¹dzenia przenoœne. Programy w nim napisane, kompilowane s¹ do poœredniego kodu, który zapisany jest w CIL (ang. Common Intermediate Language) i wykonany w œrodowisku uruchomieniowym .NET Frameworka. Poziom trudnoœci nauki C\# uznawany jest za stosunkowo niski, g³ównie z powodu posiadania licznych udogodnieñ oraz modu³ów, które upraszczaj¹ pracê programistyczn¹. Do elementów tych mo¿na zaliczyæ brak koniecznoœci dodawania plików nag³ówkowych, które niezbêdne by³y w jêzyku C++, automatyczne zwalnianie dynamicznie przydzielonej pamiêci za które odpowiedzialny jest Garbage Collection, inicjalizowanie zmiennych ich domyœlnymi wartoœciami oraz wprowadzenie dodatkowych elementów sk³adowych klas, takich jak indeksery oraz w³aœciwoœci (ang. properties).

\subsubsection{WPF / XAML}

Windows Presentation Foundation (WPF) jest to silnik graficzny, który wprowadzony zosta³a wraz z trzeci¹ wersj¹ œrodowiska .NET. Okna w aplikacjach zaimplementowanych w WPF wyœwietlane s¹ za pomoc¹ grafiki wektorowej, która to wspomagana jest przez akceleratory grafiki 3D. API w technologi WPF opiera siê na jêzyku XML, a konkretniej jego odmianie - XAML. Extensible Application Markup Language (XAML) jest to deklaratywny jêzyk znaczników, którego przeznaczeniem jest opis interfejsu u¿ytkownika implementowanego w WPF. Pozwala on zaprojektowanie oraz rozmieszczenie wszelakich elementów wizualnych oraz umo¿liwia zrównoleglenie pracy programistów pracuj¹cych nad logik¹ biznesow¹ budowanej aplikacji oraz grafików, którzy odpowiedzialni s¹ za stworzenie graficznego interfejsu u¿ytkownika. Zdarza siê, i¿ graficy przez wzgl¹d na zakres swoich obowi¹zków nie znaj¹ ¿adnego jêzyka programowania. Problem ten zanika dziêki jêzykowi XAML, który pozwala na zrozumienie przez osoby nietechniczne zasady dzia³ania oraz powi¹zañ poszczególnych okien, a tak¿e umo¿liwia projektowanie GUI w prosty sposób z poziomu drzewiastej struktury lub dedykowanego programu graficznego Expression Blend. Aplikacja ta umo¿liwia przeprowadzenie wszelkich operacji z poziomu graficznego œrodowiska.

\subsubsection{TSQL}

Transaction-SQL (T-SQL) jest to rozwiniêcie standardowego jêzyka SQL, który to utworzony zosta³ w latach siedemdziesi¹tych specjalnie na potrzeby relacyjnych baz danych przez firmê IBM. T-SQL pozwala na tworzenie konstrukcji takich jak instrukcje warunkowe i pêtle oraz umo¿liwia stosowanie zmiennych. Aktualnie stosowany on jest do tworzenia zapytañ bazodanowych przez firmy, które potrzebuj¹ bardziej zaawansowanych struktur ni¿ tych, które dostêpne s¹ w SQL. T-SQL wprowadzi³ mo¿liwoœæ stosowania bazodanowych wyzwalaczy, procedur oraz funkcji sk³adowanych, które to przy rozbudowanej strukturze tabel u³atwiaj¹ i zwiêkszaj¹ efektywnoœæ podczas pracy bazy danych.

\subsection{Zastosowane narzêdzia}

W celu efektywnej pracy z technologiami, które opisane zosta³y w rozdziale 4.1 warto u¿yæ dedykowanych narzêdzi, które u³atwiaj¹ zastosowanie potencja³u wspomnianych technologii. W tym celu w trakcie pracy nad prezentowanych projektem magisterskim, u¿ytych zosta³o kilka narzêdzi, które pozwoli³y skróciæ czas potrzebny na implementacjê aplikacji, przeprowadzenie badañ oraz zagregowanie ich rezultatów.

\subsubsection{Matlab}

TODO

\subsubsection{SQL Server Management Studio 17}

W czasie pracy nad aplikacj¹ automatyzuj¹c¹ proces przeprowadzania testów wykorzystano darmowe narzêdzie, którego przeznaczeniem jest zarz¹dzanie baz¹ danych - SQL Server Management Studio 17. Potrzeba u¿ycia narzêdzia wynik³a z istniej¹cej infrastruktury aplikacji, która opiera siê na rozwi¹zaniach Microsoftu. Zastosowane narzêdzie znacznie u³atwi³o pracê i wspomog³o proces projektowania bazy danych dziêki funkcjonalnoœci generowania diagramów, które umo¿liwi³y podgl¹d struktury bazy oraz relacji pomiêdzy poszczególnymi tabelami. Kolejn¹ olbrzymi¹ zalet¹ SQL Management Studio jest mo¿liwoœæ tworzenia zapytañ bazodanowych, które pozwalaj¹ w bardzo elastyczny sposób pogrupowaæ olbrzymie iloœci danych w wybrany przez u¿ytkownika sposób. Umo¿liwia to w szybkim tempie stworzenie statystyk zastosowanych algorytmów, które dynamicznie bêd¹ siê aktualizowa³y wraz z nap³ywem kolejnych danych do bazy.

\subsubsection{Visual Studio 2015}

Visual Studio jest to bardzo rozbudowane œrodowisko deweloperskie firmy Microsoft. Stosowane jest do procesu wytwarzania oprogramowania z graficznym interfejsem u¿ytkownika w technologii WPF, Win Forms, Web Sites oraz Xamarin. Visual Studio posiada zaawansowany edytor kodu, który wspiera mechanizm podpowiadania sk³adni kodu - IntelliSense, który mo¿e byæ dodatkowo rozbudowany poprzez dedykowane narzêdzia np. Resharper. Zintegrowany debbuger zawarty w œrodowisku Visual Studio umo¿liwia równie¿ analizê programu w czasie jego dzia³ania co w bardzo ³atwy sposób umo¿liwia odnalezienie potencjalnych b³êdów oraz sprawdzenie poprawnoœci zaimplementowanego rozwi¹zania. Funkcje te, wraz z wbudowanym designerem do tworzenia aplikacji WPF oraz narzêdziem do projektowania baz danych umo¿liwi³y skoncentrowanie pracy programistycznej przy jednym narzêdziu, dziêki czemu mo¿liwa by³a znaczna oszczêdnoœæ czasowa w temacie poszukiwañ niezbêdnych narzêdzi i ich integracji. Visual Studio, SQL Server Management Studio 17 oraz zastosowane technologie s¹ wytwarzane przez jedn¹ firmê - Microsoft. Dziêki temu aspektowi ich po³¹czenie i synchronizacja jest bezproblemowa i bardzo szybka.

\subsubsection{Resharper}

Wydajnoœæ pracy w temacie projektów programistycznych jest priorytetem, który bezpoœrednio przek³ada siê na oszczêdnoœæ czasow¹, a co za tym idzie na korzyœci finansowe. Dostêpne s¹ narzêdzia, których przeznaczeniem jest poprawienie efektywnoœci osoby implementuj¹cej aplikacjê poprzez kontrolê pisanego kodu wed³ug zdefiniowanych uprzednio zasad oraz zautomatyzowanie czêsto powtarzalnych czynnoœci. Resharper jest to dodatek do œrodowiska Visual Studio, który w znacznym stopniu rozbudowuje dostêpne jego funkcjonalnoœci, u³atwiaj¹c przy tym refaktoryzacjê oraz pisanie kodu. 
Funkcje, które zastosowane byæ mog¹ z poziomu Resharpera mo¿na pogrupowaæ na kilkanaœcie grup, z których jedn¹ z najwa¿niejszych jest modu³, który zajmuje siê inspekcj¹ kodu. W trakcie pisania kodu z uruchomionym w tle Resharperem nastêpuje sprawdzanie w czasie rzeczywistym ponad 2000 zasad, które dotycz¹ jego poprawnoœci i w czasie znalezienia niespójnoœci, nastêpuje poinformowanie programisty  z poziomu interfejsu Visual Studio o zaistnia³ym b³êdzie wraz z jego szczegó³owym opisem i miejscem wyst¹pienia. Niespójnoœci te mog¹ dotyczyæ dla przyk³adu mo¿liwoœci zast¹pienia czêœci kodu jego wydajniejsz¹ wersj¹, ostrze¿eniem programisty przed fragmentem kodu, który potencjalnie mo¿e spowodowaæ b³êdne dzia³anie ca³ej aplikacji oraz fragmentami martwego kodu.
Kolejn¹ bardzo wa¿n¹ grup¹ funkcji jest funkcja generowania kodu. W czasie pracy implementacyjnej, sporo czynnoœci takich jak edycja nazw czy pisanie nowych klas oraz metod notorycznie siê powtarza. Za pomoc¹ skrótów klawiaturowych, wszystkie powy¿sze akcje Resharper wykona za programistê. Wygeneruje on niezbêdne przy dziedziczeniu interfejsu wszystkie jego sk³adowe, przeniesie dan¹ klasê do odrêbnego pliku oraz automatycznie dokona zamiany wybranej nazwy na inn¹ w obrêbie ca³ej solucji. 
Zaprezentowane funkcje Resharpera wraz z innymi, które dostêpne s¹ do wgl¹du w odnoœniku NUMER, umo¿liwi³y zmniejszenie czasu potrzebnego na implementacjê niezbêdnych w projekcie modu³ów poprzez zminimalizowanie liczby pojawiaj¹cych siê zagro¿eñ we wczesnej fazie implementacji oraz zautomatyzowanie powtarzalnych czynoœci.  

\subsection{Wykorzystane biblioteki zewnêtrzne}

W trakcie budowy systemu informatycznego zdarzaj¹ siê sytuacje, w których korzysta siê z aplikacji ró¿nych firm, które domyœlnie nie umo¿liwiaj¹ ich po³¹czenia. Problem taki wyst¹pi³ równie¿ w czasie pracy nad prezentowanym projektem magisterskim. U¿ycie narzêdzia innej firmy ni¿ Microsoft, jakim jest Matlab doprowdzi³o do koniecznoœci znalezienia metody jego po³¹czenia ze œrodowiskiem .NET

\subsubsection{Matlab Application Type Library v.1.0}

Matlab Application Type Library w wersji pierwszej jest to otwarta biblioteka przeznaczona dla œrodowiska .NET posiadaj¹ca API umo¿liwiaj¹ce wykonywanie opracji Matlabowych stosuj¹c sk³adniê C\#. Biblioteka ta umo¿liwia odwo³ywanie siê do uprzednio zdefiniowanych w Matlabie funkcji, dostarczaj¹c odpowiednie parametry oraz odbiera wynik obliczeñ, które mo¿e byæ dalej przetwarzane bez koniecznoœci manualnego kopiowania danych w aplikacji Matlab. Biblioteka posiada bardzo ogólnie zdefiniowane metody, do prawid³owego wykonania których niezbêdna jest szczegó³owa wiedza, która ograniczona jest jednak przez wzgl¹d na brak dokumentacji. Przy d³u¿szej pracy jest jednak mo¿liwe dojœcie do sposobu skorzystania z zaawansowanych funkcji które dostarcza œrodowisko Matlab. W rozdziale NUMER przedstawiono dok³adny sposób przekazywania i odbierania danych pomiêdzy œrodowiskiem Matlab oraz .NET.

\section{Architektura budowanej aplikacji}

Budowanie bazodanowej aplikacji komputerowej ³¹cz¹cej siê z systemem trzecim wymaga szczegó³owej analizy wszystkich elementów, które maj¹ odniesienie do jej architektury. Przez koniecznoœæ budowy dwóch oddzielnych elementów - bazy danych oraz aplikacji desktopowej, analiza ta podzielona zosta³ na czêœæ odwo³uj¹c¹ siê do architektury aplikacji, modelowania bazy danych oraz komunikacji bazy danych z projektem programistycznym oraz komunikacji œrodowiska Matlab z implementowan¹ aplikacj¹. 
\subsection{Architektura aplikacji}

W aspekcie programowania, podobnie jak w innych dziedzinach, w których przeprowadzana jest operacja budowy zadanego elementu, trzeba dok³adnie zaplanowaæ jego proces. W przedstawianym rozdziale przedstawiony zosta³ opis metodologii, która pozwala na uporz¹dkowanie procesu budowania aplikacji komputerowej wraz z jej odmian¹, która zastosowana zosta³a podczas pracy nad niniejsz¹ prac¹ magistersk¹. W rozdziale XXXXX zosta³ równie¿ zawarty szczegó³owy opis poszczególnych elementów ze strony projektu programistycznego, który to jest efektem pracy implementacyjnej.
 
\subsubsection{Wzorce architektoniczne oprogramowania}

Bardzo dobr¹ praktyk¹ programistyczn¹ jest przeprowadzenie procesu budowy aplikacji w taki sposób, aby mo¿liwy by³ efektywny jej rozwój oraz dokonanie w ³atwy sposób zmian w istniej¹cych ju¿ funkcjonalnoœciach. W tym celu, budowê aplikacji nale¿y przeprowadzaæ zgodnie z ustalonymi etapami produkcji oprogramowania. Etapy te definiuj¹ obowi¹zek ustalenia wymagañ budowanego oprogramowania oraz okreœlenia jego ogólnej architektury. Czêœæ dotycz¹ca okreœlenia architektury jest niebywale wa¿na poniewa¿ zmiana architektury aplikacji podczas fazy implementacji jest niebywale problematyczna i w wielu przypadkach wrêcz niemo¿liwa bez koniecznoœci powtórnego rozpoczêcia pracy od pocz¹tku.0
\subsubsection{Zastosowany wzorzec architektoniczny – MVVM}
\subsubsection{Model aplikacji}
\subsection{Architektura bazy danych}
\subsubsection{MS-SQL – Zastosowany system zarz¹dzania baz¹ danych}
\subsubsection{Budowa bazy danych u¿ytej w projekcie}
\subsection{Komunikacja bazy danych z projektem programistycznym}
\subsubsection{Mapowanie obiektowo-relacyjne}
\subsubsection{Zastosowane narzêdzie ORM – Entity Framework}
\subsection{Komunikacja Matlaba z projektem programistycznym}
\section{Badania eksperymentalne}
\subsection{Metody porównawcze wybranych algorytmów}
\subsection{Opis przeprowadzonych badañ}
\subsection{Wyniki doœwiadczeñ dla zadanych funkcji testowych}
\subsubsection{Funkcja Bochachevsky’ego}
\subsubsection{Funkcja Beale’a}
\subsubsection{Funkcja Rosenbrocka}
\subsubsection{Funkcja Easoma }
\subsubsection{Funkcja Eggholdera}
\subsubsection{Funkcja Griewanka}
\section{Wnioski}
\section{Podsumowanie}

\end{document}
