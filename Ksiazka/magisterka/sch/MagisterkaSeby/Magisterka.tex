\documentclass[twoside]{projektMagisterski}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{amsmath}
\usepackage{xcolor}

\definecolor{red}{rgb}{0.95,0,0}

%\drukJednostronny

%% tytu³ promotor i autor (\title to komenda standardowa)
\title{Analiza porównawcza algorytmów metaheurystycznych do rozwi¹zywania wybranego problemu optymalizacyjnego}
\promotor{dr in¿. Henryk Josiñski}


%% ka¿dy autor musi mieæ 3 argumenty: imiê nazwisko, nr albumu, opis wk³adu
\autor{Sebastian Nalepka}{111111}
	


%\NumeryNaPoczatku
%% numeracja wzorów tu w³¹czona typu (1.2.3), ta druga to typu (1.2), domyœlnie typu (1)
%\subsectionWzory
% \sectionWzory  

%\rozdzialy


%\literowaNumeracjaDodatkow %% w³¹czy numeracjê dodatków literami
%\rzymskaNumeracjaDodatkow  %%w³¹czy numeracjê dodatków liczbami rzymskimi

%% wy³¹czenie wyjaœnieñ:
\bezWyjasnien

%% standardowe komendy \newtheorem  dzia³aj¹ jak woryginale
\newtheorem{tw}{Twierdzenie}%[subsection]
\newtheorem{twa}{Twierdzenie}%[section]
\newtheorem{dd}{Definicja}%[subsection]

\begin{document}

W otaczaj¹cym nas œwiecie obecnych jest wiele problemów, z którymi zmagaj¹ siê ludzie. Czêœæ z nich jest problemami prostymi, do rozwi¹zania których wystarczy wy³¹cznie niedu¿y nak³ad czasu. Istniej¹ jednak problemy trudniejsze, które wymagaj¹ d³ugotrwa³ych przemyœleñ i obliczeñ po których nie zawsze otrzymujemy najlepsze rozwi¹zanie. Do prostych problemów mo¿emy zaliczyæ codzienne decyzje podejmowane przez ka¿dego cz³owieka. Dla przyk³adu jeœli chcemy dojechaæ z punktu A do punktu B komunikacj¹ miejsk¹, wystarczy, ¿e sprawdzimy rozk³ad jazdy i wybierzemy po³¹czenie, które bêdzie pasowa³o nam w kontekœcie godziny przyjazdu na dane miejsce. Przedstawiony problem posiada z go³a inn¹ skalê trudnoœci ze strony przewoŸnika. Wyznaczenie optymalnych tras przewozowych dla okreœlonej liczby œrodków transportu, w celu obs³u¿enia danego zbioru klientów, którzy rozlokowani s¹ w ró¿nych punktach jest kwesti¹ bardzo skomplikowan¹. Znalezienie optymalnych tras, które umo¿liwi¹ przetransportowanie jak najwiêkszej iloœci osób w celu zmaksymalizowania zysku, przy zachowaniu mo¿liwie najkrótszych tras, których zamys³em jest minimalizowanie kosztów poniesionych z transportem jest z³o¿onym problemem, znanym jako jedna z odmian problemu marszrutyzacji, który jest z kolei rozwiniêciem bardzo popularnego problemu komiwoja¿era. Problem ten polega na znalezieniu najkrótszej drogi ³¹cz¹cej wszystkie zdefiniowane uprzednio punkty, zaczynaj¹c i koñcz¹c w tym samym miejscu. Problemy, do rozwi¹zania których potrzebne s¹ ogromne nak³ady obliczeniowe definiowane s¹ jako problemy optymalizacyjne. W problemach takich liczba mo¿liwych rozwi¹zañ w przestrzeni poszukiwañ z regu³y jest tak du¿a, ¿e niemo¿liwe jest przeszukiwanie wyczerpuj¹ce w celu znalezienia najlepszego z nich. 

\subsection*{Cel pracy}

Celem pracy jest dokonanie analizy porównawczej algorytmu symulowanego wy¿arzania, algorytmu genetycznego oraz roju cz¹stek, która przeprowadzona bêdzie dziêki zaimplementowanej dedykowanej aplikacji bazodanowej, której przeznaczeniem jest zautomatyzowanie procesu szukania minimum globalnego zadanych dla funkcji testowych.

\subsection*{Zawartoœæ pracy}

Dla osi¹gniêcia wy¿ej wymienionego celu zrealizowana zosta³a praca sk³adaj¹ca siê z szeœciu rozdzia³ów oraz wniosków przeprowadzonych doœwiadczeñ wraz z podsumowaniem. W rozdziale pierwszym przedstawiony zosta³ wybór problemu optymalizacyjnego wraz z jego opisem oraz list¹ funkcji testowych, które u¿yte zosta³y do przeprowadzenia badañ. Rozdzia³ drugi przedstawia mo¿liwe sposoby rozwi¹zania wybranego problemu optymalizacyjnego wraz z opisem u¿ytych algorytmów metaheurystycznych. Na bazie dwóch pierwszych rozdzia³ów utworzony zosta³ w rozdziale trzecim projekt automatyzacji przeprowadzanych doœwiadczeñ, na podstawie którego bazowa³a budowana aplikacja. Kolejny rozdzia³ to zastosowane rozwi¹zania technologiczne oraz opis wykorzystanych technologii, bibliotek zewnêtrznych, a tak¿e narzêdzi. Na ich podstawie utworzona zosta³a architektura aplikacji bazodanowej, której specyfikacja umiejscowiona zosta³a w rozdziale pi¹tym. Kolejny rozdzia³ prezentuje ju¿ œciœle aspekt badawczy, który zawiera  opis metod porównawczych zastosowanych algorytmów oraz wyniki doœwiadczeñ dla u¿ytych funkcji testowych, których analiza przeprowadzona zosta³a w rozdziale siódmym zawieraj¹cym wnioski.

\section{Wybór badanego problemu optymalizacji}

\subsection{Opis minimalizacji funkcji ci¹g³ych wielu zmiennych}

W prezentowanej pracy dokonano porównania algorytmów metaheurystycznych odnosz¹c siê do problemu minimalizacji funkcji wielu zmiennych. Problem ten polega na znalezieniu minimum globalnego rzeczywistej funkcji poprzez systematyczne wybieranie parametrów wejœciowych z dozwolonego zakresu i obliczaniu ich wartoœci funkcji. Trudnoœæ problemu sprowadza siê do wielkoœci przestrzeni przeszukiwania. Traktuj¹c problem jako czysto matematyczny, funkcja \textit{n} zmiennych posiada nieskoñczenie wiele wartoœci w ka¿dym wymiarze. Mamy wiêc nieskoñczenie wielk¹ przestrzeñ poszukiwañ. Bior¹c jednak pod wzgl¹d aspekt technologiczny i to, i¿ komputery bazuj¹ na danych skoñczonych, mo¿na w prosty sposób przedstawiæ skalê trudnoœci. W czasie implementacji algorytmu, którego celem jest znalezienie minimum globalnego funkcji, nale¿y wzi¹æ pod uwagê dostêpn¹ dok³adnoœæ obliczeniow¹ maszyny. Zak³adaj¹c, i¿ dok³adnoœæ ta wynosi osiem miejsc po przecinku, ka¿da zmienna, ograniczona w przedziale $[0,100]$ mo¿e przyj¹æ $100*10^8$ ró¿nych wartoœci. Ju¿ dla funkcji dwóch zmiennych, wielkoœæ przestrzeni przeszukiwania wynosi $(100*10^8)^2 = 10^{20}$.

\subsection{Funkcje testowe}

Problem minimalizacji funkcji ci¹g³ych bardzo dobrze nadaje siê do porównania algorytmów metaheurystycznych przez wzgl¹d na powszechnie dostêpne funkcje testowe. Funkcje te posiadaj¹ pewny specyficzny element, dziêki któremu mo¿liwe jest porównanie wyników otrzymanych przez dany algorytm. Element ten to znajomoœæ minimum globalnego dla danej funkcji testowej. Dziêki znajomoœci wartoœci najlepszej (najmniejszej) dla danej funkcji, wiadomo jak szybko oraz czy w ogóle badany algorytm znalaz³ rozwi¹zanie. Posiadaj¹c ten punkt odniesienia mo¿na zestawiæ otrzymane rezultaty wszystkich algorytmów pod k¹tem czasowym lub liczby wyliczeñ wartoœci funkcji dla ustalonych przez algorytm punktów.
Do analizy wybranych zosta³o (TODO: wpisac ilosc) funkcji testowych, których dobór bra³ pod uwagê stopieñ ich skomplikowania. Funkcje te zosta³y wybrane z listy zawartej w (TODO: link do strony z lista funkcji) uwzglêdniaj¹c ró¿n¹ liczbê wymiarów oraz skalê ich trudnoœci. Ka¿da z funkcji posiada specyficzne w³aœciwoœci, które zostan¹ wziête pod uwagê podczas porównania rezultatów algorytmów heurystycznych.

\subsubsection{Funkcja Bohachevsky’ego 1}

Funkcja Bohachevsky'ego 1 jest stosunkowo prost¹ do minimalizacji funkcja dwóch zmiennych, której wykres przybiera kszta³t ³uku. Z regu³y jest ona badana w zakresie $x_i \in[-100,100]$ dla $i=1,2$. W przedstawianej pracy magisterskiej granice to zosta³y jednak dwukrotnie powiêkszone i wynosz¹ $[-200,200]$. Wed³ug doœwiadczeñ przeprowadzonych w (TODO: link to strony z rankingiem), $81.75\%$ doœwiadczeñ zakoñczonych zosta³o znalezieniem minimum globalnego, które dla funkcji Bohachevsky'ego wynosi 0, dla punktu $x=(0,0)$.

TODO: obrazek + wzór

\subsubsection{Funkcja Colville'a}

Jest to funkcja czterech zmiennych, która posiada jedno minimum globalne o wartoœci 0 dla punktu $x=(1,1,1,1)$ oraz analizowana jest zazwyczaj na hiperszeœcianie $x_i\in[-200,200]$ dla $i=1,2,3,4$. Wed³ug danych zawartych(TODO: link do rank) jest to funkcja trudniejsza w minimalizacji od funkcji Bohachevsky'ego, której procentowy sukces dotycz¹cy znalezienie minimum globalnego wyniós³ $72.00\%$.
 
 TODO: obrazek + wzór

\subsubsection{Funkcja Ackley'a}

Funkcja Ackley'a jest popularn¹ funkcj¹ dla testów optymalizacyjnych algorytmów. W swojej dwuwymiarowej postaci, któr¹ ukazano na obrazku (TODO: rys odnos), charakteryzuje siê prawie p³askim obszarem zewnêtrznym i du¿ym otworem w centrum. Funkcja stwarza ryzyko dla algorytmów optymalizacyjnych poprzez mo¿liwoœæ zatrzymania siê w jednym z licznych lokalnych minimów. Istnieje mo¿liwoœæ rozszerzenia funkcji Ackley'a na wiele wymiarów co te¿ uczyniono w prezentowanej pracy magisterskiej, w której rozpatrywana jest ona dla czterech zmiennych. Minimum globalne umiejscowione jest w punkcie $x=(0,0,0,0)$ i jego wartoœæ wynosi 0. Dziedzina funkcji z kolei analizowana bêdzie w przedziale $x_i\in[-150,150]$ dla $i=1,2,3,4$. Dla wspomnianych ju¿ testów, których wyniki dostêpne s¹ do wgl¹du w odnoœniku (TODO: odn do rank), procentowy sukces znalezienia minimum globalnego wyniós³ $48.25\%$.
 
  TODO: obrazek + wzór
  
\subsubsection{Funkcja Eggholdera }

Kolejn¹ wybran¹ funkcj¹ zosta³a dwuwymiarowa funkcja Eggholdera. Jest to funkcja, której graficzna reprezentacja zawarta w rysunku(TODO: dodaj rys i alias) przypomina pasmo górskie z licznymi dolinami. Jest to funkcja trudna do optymalizacji przez wzgl¹d na licznie wystêpuj¹ce minima lokalne. Dziedzina funkcji powszechnie rozpatrywana jest w przedziale $x_i\in[-512,512]$ dla $i=1,2$. Minimum globalne znajduje siê w punkcie $x=(512,404.2319)$ i wynosi $-959.6407$. Przez wzgl¹d na jego nietypowe po³o¿enie i wspomniane ju¿ liczne minima lokalne, wy³¹cznie $18.92\%$ testów zawartych w (TODO: odnosnik do rank) zakoñczy³o siê jego znalezieniem.

\subsubsection{Funkcja Rosenbrocka}

Funkcja Rosenbrocka jest to niewypuk³a funkcja, która jest bardzo popularna w kontekœcie optymalizacji jako test dla algorytmów optymalizacyjnych. Nazywana jest równie¿ przez wzgl¹d na swój kszta³t "Funkcj¹ Bananow¹ Rosenbrocka" albo "Dolin¹ Rosenbrocka". Funkcja Rosenbrocka powszechnie jest stosowana w kontekœcie optymalizacji funkcji dwóch zmiennych. Istnieje jednak mo¿liwoœæ rozszerzenia jej do wielu wymiarów. W prezentowanej pracy magisterskiej rozpatrywana jest funkcja Rosenbrocka czterech zmiennych, której minimum globalne mieœci siê w punkcie $x=(1,1,1,1)$ i wynosi 0. Ustalon¹ dziedzin¹ funkcji jest $x_i\in[-200,200]$ dla $i=1,2,3,4$. Opisywana funkcja Rosenbrocka jest funkcj¹ trudn¹ do minimalizacji i wed³ug wyników testów zawartych w (TODO: link do rank) procentowy sukces znalezienia minimum globalnego wyniós³ tylko $8,42\%$.

TODO: obrazek + wzor 2 i 4zm

\subsubsection{Funkcja Griewanka}
6.08%

\textcolor{brown}{Opis funkcji wraz z ich w³aœciwoœciami opisaæ po definitywnym ich wyborze (poczekaæ na fazê testów)}

\section{Metody rozwi¹zania wybranego problemu optymalizacji}

\subsection{Algorytmy dok³adne}

Klasycznym podejœciem do znalezienia minimalnej wartoœci zadanej funkcji testowej jest próba porównania wartoœci funkcji dla ka¿dych mo¿liwych parametrów wejœciowych i wybrania w ten sposób optymalnego rozwi¹zania. W rzeczywistoœci jednak takie rozwi¹zanie nie jest praktyczne przez wzgl¹d na olbrzymi¹ mo¿liw¹ liczbê takich parametrów. Jak ju¿ wspomniano w rozdziale 1.1 (TODO: zmieniæ na alias rozdzia³u) liczba rozwi¹zañ dla funkcji ograniczonej ju¿ do dwóch zmiennych mo¿e wynieœæ $10^{20}$, a w przypadku trzech zmiennych – $10^{30}$. Zak³adaj¹c, i¿ mo¿liwe by by³o wyliczenie miliarda wartoœci funkcji na sekundê, to w godzinê wartoœæ ta wynosi³aby  $3.6*10^{12}$, a w rok – $3.2*10^{16}$. Prowadz¹c dalej obliczenia wychodzi, i¿ wyliczenie $10^{20}$ wartoœci funkcji trwa³oby oko³o 3125 lat. Widaæ wiêc, ¿e liczba kombinacji jest tak du¿a, i¿ podejœcie to jest niemo¿liwe do wykonania w akceptowalnym czasie.

\subsection{Metaheurystyki optymalizacyjne}

Analizuj¹c podejœcie z rozdzia³u 2.1 (TODO: dodaæ alias rozdzia³u) mo¿e przyjœæ na myœl sposób, który polegaæ bêdzie na wyliczaniu wartoœci funkcji dla wyrywkowych parametrów. Sk¹d jednak wiadomo które punkty wybraæ? Na podstawie czego bazowaæ? W przypadku problemów, w których przez wzgl¹d na czas niemo¿liwe jest dojœcie do rozwi¹zania na ratunek przychodz¹ algorytmy heurystyczne, które umo¿liwiaj¹ skrócenie czasu obliczeñ. Cen¹ któr¹ trzeba jednak za to zap³aciæ jest mo¿liwoœæ otrzymania gorszego rozwi¹zania od rozwi¹zania najlepszego. Samo pojêcie heurystyki pochodzi od greckiego s³owa heuresis, które znaczy ‘odnaleŸæ’. Metody heurystyczne polegaj¹ na u¿yciu regu³ oraz faktów, które uzyskane na drodze badania danego problemu umo¿liwiaj¹ jego rozwi¹zanie lub zbli¿enie siê do poprawnej odpowiedzi. Podejœcie heurystyczne stosowane mo¿e byæ w sposób piêtrowy, tworz¹c metaheurystyki. Metaheurystyka jest to ogólny algorytm do rozwi¹zywania problemów obliczeniowych, który inspiracjê czêsto bierze z mechanizmów biologicznych lub fizycznych. Okreœlenie to oznacza tak zwan¹ heurystykê wy¿szego poziomu, co wynika z faktu, i¿ algorytmy tego typu bezpoœrednio nie rozwi¹zuj¹ ¿adnego problemu, a wy³¹cznie podaj¹ metodê na utworzenie odpowiedniego algorytmu. 


\subsubsection{Metoda optymalizacji rojem cz¹stek}

Metoda roju cz¹stek (PSO – Particle Swarm Optimization) jest przyk³adem optymalizacji z kategorii metod inteligencji stadnej. Powsta³a ona w wyniku inspiracji biologicznej, której Ÿród³em by³ uk³ad lotu stada ptaków tworzony w celu znalezienia po¿ywienia lub gniazda oraz unikniêcia drapie¿ników. Zastosowanie prostych zasad umo¿liwia ptakom zsynchronizowany oraz bezkolizyjnych ruch, który daje efekt zachowania jednego organizmu. Ruch stada ptaków, czy ³awicy ryb jest wypadkow¹ dzia³ania wszystkich osobników i koncentruje siê na utrzymaniu optymalnego dystansu od swoich s¹siadów, przy jednoczesnym pod¹¿aniem za liderem. Badania nad optymalizacj¹ roju cz¹stek zapocz¹tkowano od próby graficznej symulacji zachowañ takich grup. Bardzo szybko okaza³o siê, i¿ stworzony matematyczny model mo¿e byæ równie¿ zastosowany jako metoda optymalizacyjna.
W optymalizacji rojem cz¹stek, rozwi¹zania (cz¹stki) wspó³pracuj¹ ze sob¹ w celu odnalezienia cz¹stki optymalnej. W czasie procesu optymalizacji nastêpuje zmiana po³o¿enia ka¿dej cz¹stki w przestrzeni rozwi¹zañ poprzez wyznaczenie wektora prêdkoœci. Wektor ten jest modyfikowany przy u¿yciu informacji o historii poszukiwañ danej cz¹stki oraz jej cz¹stek s¹siednich. Metoda PSO w problemie optymalizacji funkcji wielowymiarowych d¹¿y do otrzymania cz¹steczki, która reprezentuje jak najmniejsz¹ wartoœæ funkcji i mo¿e byæ opisana dwoma równaniami:

\begin{equation}
v=W*v+c_1*r_1*(p-x)+c_2*r_2*(g-x)
\end{equation}
gdzie,

$v$ - aktualny wektor prêdkoœci cz¹stki

$W$ – parametr z zakresu $[0,1]$, który determinuje wp³yw poprzedniego po³o¿enia cz¹stki na jej obecn¹ pozycjê

$p$ - najlepsze rozwi¹zanie dla cz¹stki

$g$ – najlepsze rozwi¹zanie dla s¹siedztwa cz¹stek

$r_1,r_2$ – losowe liczby z zakresu $[0,1]$

$c_1,c_2$ – parametry skaluj¹ce z zakresu $[0,1]$

Nawi¹zuj¹c do powy¿szych równañ, ka¿da cz¹stka roju przeszukuje przestrzeñ rozwi¹zañ zmieniaj¹c po³o¿enie na podstawie swoich najlepszych rozwi¹zañ $p_i$, jednoczeœnie wykorzystuj¹c informacjê o najlepszym rozwi¹zaniu w s¹siedztwie $p_t$. Parametry skaluj¹ce umo¿liwiaj¹ kontrolê wp³ywu danych czêœci wektora prêdkoœci na wynik. W przypadku, w którym $c_1$ bêdzie równe zero, cz¹stka bêdzie wykorzystywa³a tylko i wy³¹cznie informacjê o najlepszym rozwi¹zaniu w roju. Z kolei jeœli wartoœæ parametru $c_2$ zostanie ustawiona na zero, cz¹stka bêdzie poszukiwa³a rozwi¹zania samodzielnie, bez uwzglêdnienia rozwi¹zañ, które uzyskane zosta³y przez inne cz¹stki. 

\subsubsection{Symulowane wy¿arzanie}

Algorytm symulowanego wy¿arzania po raz pierwszy zosta³ opisany w 1953 roku przez Nicolasa Metropolisa. Sposób dzia³ania algorytmu jak i równie¿ jego nazwa odnosi siê do procesów fizycznych, które wykorzystywane s¹ w metalurgii. Proces wy¿arzania polega na rozgrzaniu cia³a sta³ego do okreœlonej temperatury, a nastêpnie jego powolnym studzeniu. Konsekwencj¹ tego dzia³ania jest zmiana struktury krystalicznej materia³u, który poddany zosta³ wy¿arzaniu. W czasie procesu och³adzania metali dostrze¿ono, i¿ cz¹steczki cia³a
wraz z jego powolnym sch³adzaniem tworz¹ bardziej regularne struktury, ni¿ w przypadku szybszego obni¿enia temperatury, kiedy to ch³odzone cz¹steczki nie potrafi¹ znaleŸæ optymalnego po³o¿enia.
Algorytm symulowanego wy¿arzania jest usprawnieniem starszych metod iteracyjnych, które polega³y na ci¹g³ym ulepszaniu istniej¹cego rozwi¹zania do momentu braku mo¿liwoœci jego poprawy. W metodach tych zatrzymanie algorytmu mog³o nast¹piæ przy rozwi¹zaniu pseudo-optymalnym – lokalnym minimum. Nie istnia³a wówczas mo¿liwoœæ wyjœcia z owego lokalnego minima i kierowania siê w kierunku minimum globalnego. Bardzo wa¿n¹ cech¹ opisywanego algorytmu jest mo¿liwoœæ wyboru, z pewnym prawdopodobieñstwem, gorszego rozwi¹zania. Dziêki temu problem utkniêcia w lokalnym minimum nie jest ju¿ groŸny. Za wybór gorszego rozwi¹zania ma wp³yw podstawowy parametr przeniesiony z podstaw termodynamicznych algorytmu – temperatura. Im jest ona wy¿sza, tym wiêksze istnieje prawdopodobieñstwo wyboru i zaakceptowania gorszego rozwi¹zania. W czasie dzia³ania algorytmu, temperatura obni¿a siê i dzia³anie algorytmu zbli¿a siê w swoim zachowaniu do typowych metod iteracyjnych.
W celu wykonania algorytmu symulowanego wy¿arzania w kontekœcie optymalizacji funkcji wielu zmiennych nale¿y na pocz¹tku losowo wygenerowaæ punkt startowy, który mieœci siê na p³aszczyŸnie poszukiwañ, wyliczyæ dla niego wartoœæ funkcji oraz wybraæ temperaturê startow¹ z dostêpnego zakresu [0,100]. Ka¿da iteracja polega na wyborze losowego rozwi¹zania z s¹siedztwa, wyliczenia dla niego wartoœci funkcji i porównaniu z obecnie najlepszym rezultatem oraz obni¿eniu temperatury. W przypadku, w którym wartoœæ funkcji nowego punktu jest mniejsza (lepsza), jest on zaklasyfikowany jako najlepszy. W przeciwnej sytuacji punkt nie jest natychmiastowo odrzucany. Algorytm akceptuje gorsze rezultaty bazuj¹c na funkcji akceptacyjnej, która prezentuje siê nastêpuj¹co:

\begin{equation}
\frac{1}{1+exp(\frac{\Delta}{max(T)})}
\end{equation}
gdzie,

$\Delta$ – ró¿nica wartoœci starego i nowego punktu

$T$ – wartoœæ temperatury

W sytuacji, w której $\Delta$ i $T$ s¹ wartoœciami dodatnimi, prawdopodobieñstwo akceptacji mieœci siê pomiêdzy 0 i $\frac{1}{2}$. Ni¿sza temperatura prowadzi do mniejszego prawdopodobieñstwa zaakceptowania gorszego rezultatu. Podobnie jest z delt¹ – im wiêksza delta tym mniejsza szansa na zaakceptowanie.

\subsubsection{Algorytm genetyczny}

Model algorytmu genetycznego po raz pierwszy zaprezentowany zosta³ w 1975 roku przez Johna Hollanda, który w pracy „Adaptation in Natural and Artifical Systems” przedstawi³ fundamenty za³o¿eñ dotycz¹cych adaptacji darwinowskiej teorii ewolucji w systemach informatycznych.  
W opisie algorytmu genetycznego pos³uguje siê powszechn¹ terminologi¹ biologiczn¹. Z tego te¿ powodu mówi siê, i¿ algorytmy genetyczne przetwarzaj¹ populacjê osobników, która reprezentuje rozwi¹zanie danego problemu. Ka¿dy element populacji nazywany jest chromosomem, a jego sk³adowe genami. Allele z kolei, s¹ to mo¿liwe stany (wartoœci) genu, które umiejscowione s¹ na pozycjach zdefiniowanych jako locus. W badanych modelach komputerowych, osobniki (chromosomy) mog¹ byæ opisane jako ró¿ne struktury – zaczynaj¹c na ³añcuchach binarnych, a koñcz¹c na bardzo z³o¿onych obiektach. W okreœlonej iteracji zwanej zamiennie pokoleniem albo generacj¹, dane chromosomy na bazie okreœlonej miary ich dostrojenia podlegaj¹ ocenie. Ocena ta skutkuje wyborem najlepiej przystosowanych osobników, które wezm¹ udzia³ w kolejnych iteracjach algorytmu. Nim jednak wybrane osobniki populacji utworz¹ now¹ generacjê, zostaj¹ poddane modyfikacjom spowodowanym podstawowymi operacjami genetycznymi – krzy¿owaniem, selekcj¹ oraz mutacj¹.
W kontekœcie problemu optymalizacji funkcji wielu zmiennych, inicjalizacja algorytmu genetycznego polega na wygenerowaniu populacji pocz¹tkowej, która z³o¿ona jest z okreœlonej liczby chromosomów. Ka¿dy chromosom reprezentowany w populacji posiada tak¹ sam¹ d³ugoœæ, która ustalona jest zale¿nie od rozwi¹zywanego problemu na etapie implementowania algorytmu. Przed nast¹pieniem etapu generowania musi byæ jednak okreœlony sposób kodowania informacji zawartej w chromosomie, która dotyczy rozwi¹zania. W algorytmie Hollanda nie by³o domyœlnie zdefiniowanego sposobu kodowania chromosomów. Powszechnie uznaje siê jednak, i¿ stosuje siê kodowanie binarne. Takie te¿ kodowanie jest zastosowane w kontekœcie omawianego problemu optymalizowania funkcji wielu zmiennych. Kolejnym etapem, który nastêpuje po wygenerowaniu populacji pocz¹tkowej oraz wyborze kodowania chromosomów jest wyznaczenie jakoœci chromosomów danej populacji. W tym celu obliczana jest wartoœæ tak zwanej funkcji oceny, która definiuje poziom dopasowania konkretnego chromosomu. Tym sposobem mo¿na stwierdziæ, które z nich lepiej rozwi¹zuj¹ dane zagadnienie, a które gorzej. Znalezienie rozwi¹zania danego problemu sprowadza siê do znalezienia ekstremum wspomnianej funkcji oceny. Kolejn¹ czêœci¹ algorytmu jest zastosowanie mechanizmu selekcji, który definiuje sposób wyboru rozwi¹zañ rodzicielskich, z których tworzone bêd¹ tak zwane rozwi¹zania potomne u¿yte w nastêpnej generacji. Podstawowy algorytm genetyczny w operacji selekcji stosuje metodê ruletki. Metoda ta polega na przydzieleniu ka¿demu chromosomowi z danej populacji prawdopodobieñstwa wed³ug wzoru:

\begin{equation}
p_i = \frac{f_i}{\sum_{j=1}^{N}f_j}
\end{equation}

gdzie,
$f_i$ - wartoœæ funkcji oceny chromosomu i-tego
$p_i$ – prawdopodobieñstwo reprodukcji

W celu wybrania puli rodzicielskiej, ko³o ruletki o obwodzie jeden dzielone jest na czêœci o d³ugoœci $p_i$, a nastêpnie z zakresu $[0,1]$ losowana jest liczba, która jednoznacznie identyfikuje punkt na ruletce, a co za tym idzie konkretny chromosom. Chromosom ten brany bêdzie pod uwagê w procesie nastêpnej reprodukcji, a losowanie powtarzane jest tak d³ugo, a¿ wylosowana zostanie ustalona liczba chromosomów. W problemie minimalizacji funkcji wielu zmiennych istnieje mo¿liwoœæ, i¿ wartoœæ funkcji oceny bêdzie ujemna. W celu zniwelowania problemu ujemnego prawdopodobieñstwa powy¿szy wzór zosta³ zmodyfikowany stosuj¹c skalowanie przystosowania:

\begin{equation}
p_i = \frac{f_i-f_{min}}{\sum_{j=1}^{N}f_j-f_{min}}
\end{equation} 

gdzie $f_{min}$ jest wartoœci¹ funkcji przystosowania najgorszego chromosomu. \newline

Po etapie selekcji pozostaje do zdefiniowania kwestia wymiany pokoleñ. W implementacjach czêsto stosowana jest metoda ca³kowitego zastêpowania, w której ca³a aktualna populacja, podlega operacjom krzy¿owania i mutacji. Innym sposobem jest metoda zastêpowania czêœciowego, w której czêœæ najlepszych chromosomów obecnej populacji przechodzi do populacji potomnej bez ¿adnych zmian, a pozosta³e elementy z kolei bior¹ udzia³ w operacji krzy¿owania i mutacji. Czêsto stosowan¹ praktyk¹ jest zastosowanie zastêpowania elitarnego, w którym na podstawie parametru okreœlaj¹cego wielkoœæ elity, czêœæ najlepszych osobników jest kopiowana do nowej generacji ju¿ na samym pocz¹tku. Umo¿liwia to zapamiêtanie najlepszych chromosomów które mog³y byæ zmienione poprzez dzia³anie operatorów genetycznych.

Pierwszym z takich operatorów jest krzy¿owanie, które jest operacj¹ umo¿liwiaj¹c¹ tworzenie nowych rozwi¹zañ. Jego koncept bazuje na procesie rozmna¿ania organizmów, w czasie trwania których dziecko dziedziczy czêœæ genów rodziców. W kontekœcie omawianego algorytmu genetycznego, krzy¿owanie polega na przeciêciu chromosomów w ustalonym punkcie i ich wzajemnego zamienienia. 
Drugim operatorem genetycznym jest mutacja, która umo¿liwia wprowadzenie nowego elementu do populacji poprzez tworzenie ró¿norodnoœci. Analogicznie jak w otaczaj¹cym nas œwiecie, w algorytmie genetycznym, mutacje zdarzaj¹ siê rzadko. Ich skala zazwyczaj zale¿y od parametru, który przyjmuje niskie wartoœci. W odniesieniu do chromosomów w postaci binarnej, mutacja mo¿e polegaæ na zamianie losowego genu na wartoœæ przeciwn¹. Tak utworzona nowa generacja ponownie przechodzi przez wszystkie punkty algorytmu. Dzieje siê tak a¿ do czasu, w którym spe³nione zostan¹ warunki zatrzymania, które w kontekœcie przedstawianego zagadnienia opisane zosta³y w rozdziale 6.1 (TODO: dodac alias rozdzialu) opisuj¹cym metody porównawcze wybranych algorytmów obejmuj¹ce w swojej treœci warunki stopu opisanych trzech metaheurystyków.

\section{Automatyzacja przeprowadzanych badañ}

Porównanie algorytmów metaheurystycznych w odniesieniu do problemu minimalizacji funkcji wielu zmiennych jest zadaniem bardzo skomplikowanym przez fakt iloœci doœwiadczeñ, które trzeba wykonaæ. Badania porównawcze przeprowadzane bêd¹ pod k¹tem kilku parametrów. Dla ka¿dego z nich nale¿y przeprowadziæ wielokrotne testy dla ka¿dego testowanego algorytmu. Ustalaj¹c próbkê testu na poziomie $10^4$ prób, z której bêdzie obliczana wartoœæ œrednia oraz bior¹c pod uwagê dwa parametry porównawcze, z których ka¿dy przyjmowaæ mo¿e dla przyk³adu dziesiêæ wartoœci, liczba testów dla jednego algorytmu oraz jednej funkcji testowej osi¹ga ju¿ wartoœæ $2*10^5$. Manualne przetwarzanie w œrodowisku Matlab przy ograniczonej funkcjonalnoœci agregowania wyników jest bardzo czasoch³onnym zadaniem. W tym celu zdecydowano siê zbudowaæ dedykowan¹ aplikacjê bazodanow¹, która bêdzie umo¿liwia³a automatyzacjê przedstawianej operacji. U¿ytkownik z poziomu aplikacji bêdzie mia³ mo¿liwoœæ wyboru funkcji testowej, algorytmu metaheurystycznego oraz jego parametrów, a tak¿e liczby testów, która ma byæ przeprowadzona przy zadanych wartoœciach. Aplikacja automatycznie bêdzie wysy³a³a zapytania do œrodowiska obliczeniowego Matlab, obiera³a wyniki oraz umieszcza³a je w bazie danych, z której w prosty i efektywny sposób mo¿na bêdzie przeprowadziæ ich agregacjê w celu przedstawienia wyników i ich porównania. W ten sposób narzut pracy, który niezbêdny jest do implementacji przedstawionej aplikacji z ca³¹ pewnoœci¹ siê zwróci oraz umo¿liwi dalsz¹ analizê algorytmów w kontekœcie problemu funkcji wielu zmiennych poniewa¿ aplikacja umo¿liwiaæ bêdzie równie¿ proste dodanie do niej kolejnych algorytmów funkcji testowych.

\section{Wykorzystane rozwi¹zania technologiczne}

\subsection{Zastosowane technologie}

Obecny rozdzia³ obejmuje opis wykorzystanych technologii, które umo¿liwi³y implementacjê aplikacji. Opis ten dotyczy jêzyka programowania, w którym napisany zosta³ backend(TODO: dodaæ przypis) aplikacji oraz silnika graficznego aplikacji wraz z jêzykiem zapytañ bazy danych.

\subsubsection{.NET Framework/C\#}

.NET Framework jest to platforma programistyczna wydana przez firmê Microsoft w 2002 roku. Przeznaczona jest ona do wytwarzania oprogramowania przeznaczonego dla systemów operacyjnych z rodziny Windows. G³ówn¹ sk³adow¹ przedstawianej platformy s¹ kompilatory jêzyków wysokiego poziomu, które umo¿liwiaj¹ przeprowadzenie operacji kompilacji programów napisanych w jêzykach Visual Basic, F\#, C++/CLI. Platforma .NET wspiera równie¿ jeden z najpopularniejszych jêzyków programowania na œwiecie - C\#, w którym napisana zosta³a aplikacja odnosz¹ca siê do prezentowanej pracy magisterskiej. Wed³ug rankingu TIOBE Software z grudnia 2015 roku, jêzyk C\# uplasowany jest na pi¹tym miejscu, spoœród piêædziesiêciu najpopularniejszych jêzyków, które zosta³y wziête pod uwagê.
C\# jest to nowoczesny, zorientowany obiektowo jêzyk programowania stworzony przez firmê Microsoft. Jego pierwsza wersja wydana zosta³a ju¿ w po³owie 2000 roku, przy du¿ej zas³udze g³ównego projektanta jêzyka - duñskiego in¿yniera oprogramowania Andersa Hejlsberga. Jêzyk ten mo¿e zostaæ u¿yty w celu pisania aplikacji webowych, desktopowych oraz przeznaczonych na urz¹dzenia przenoœne. Programy w nim napisane, kompilowane s¹ do poœredniego kodu, który zapisany jest w CIL (ang. Common Intermediate Language) i wykonany w œrodowisku uruchomieniowym .NET Frameworka. Poziom trudnoœci nauki C\# uznawany jest za stosunkowo niski, g³ównie z powodu posiadania licznych udogodnieñ oraz modu³ów, które upraszczaj¹ pracê programistyczn¹. Do elementów tych mo¿na zaliczyæ brak koniecznoœci dodawania plików nag³ówkowych, które niezbêdne by³y w jêzyku C++, automatyczne zwalnianie dynamicznie przydzielonej pamiêci za które odpowiedzialny jest Garbage Collection, inicjalizowanie zmiennych ich domyœlnymi wartoœciami oraz wprowadzenie dodatkowych elementów sk³adowych klas, takich jak indeksery oraz w³aœciwoœci (ang. properties).

\subsubsection{WPF / XAML}

Windows Presentation Foundation (WPF) jest to silnik graficzny, który wprowadzony zosta³ wraz z trzeci¹ wersj¹ œrodowiska .NET. Okna w aplikacjach zaimplementowanych w WPF wyœwietlane s¹ za pomoc¹ grafiki wektorowej, która to wspomagana jest przez akceleratory grafiki 3D. API w technologi WPF opiera siê na jêzyku XML, a konkretniej jego odmianie - XAML. Extensible Application Markup Language (XAML) jest to deklaratywny jêzyk znaczników, którego przeznaczeniem jest opis interfejsu u¿ytkownika implementowanego w WPF. Pozwala on zaprojektowanie oraz rozmieszczenie wszelakich elementów wizualnych oraz umo¿liwia zrównoleglenie pracy programistów pracuj¹cych nad logik¹ biznesow¹ budowanej aplikacji oraz grafików, którzy odpowiedzialni s¹ za stworzenie graficznego interfejsu u¿ytkownika. Zdarza siê, i¿ graficy przez wzgl¹d na zakres swoich obowi¹zków nie znaj¹ ¿adnego jêzyka programowania. Problem ten zniwelowany dziêki jêzykowi XAML, który pozwala na zrozumienie przez osoby nietechniczne zasady dzia³ania oraz powi¹zañ poszczególnych okien, a tak¿e umo¿liwia projektowanie GUI w prosty sposób z poziomu drzewiastej struktury lub dedykowanego programu graficznego Expression Blend. Aplikacja ta umo¿liwia przeprowadzenie wszelkich operacji z poziomu graficznego œrodowiska.

\subsubsection{TSQL}

Transaction-SQL (T-SQL) jest to rozwiniêcie standardowego jêzyka SQL, który to utworzony zosta³ w latach siedemdziesi¹tych specjalnie na potrzeby relacyjnych baz danych przez firmê IBM. T-SQL pozwala na tworzenie konstrukcji takich jak instrukcje warunkowe i pêtle oraz umo¿liwia stosowanie zmiennych. Aktualnie stosowany on jest do tworzenia zapytañ bazodanowych przez firmy, które potrzebuj¹ bardziej zaawansowanych struktur ni¿ tych, które dostêpne s¹ w SQL. T-SQL wprowadzi³ mo¿liwoœæ stosowania bazodanowych wyzwalaczy, procedur oraz funkcji sk³adowanych, które to przy rozbudowanej strukturze tabel u³atwiaj¹ i zwiêkszaj¹ efektywnoœæ podczas pracy z baz¹ danych.

\subsection{Zastosowane narzêdzia}

W celu efektywnej pracy z technologiami, które opisane zosta³y w rozdziale 4.1 (TODO: dodaæ alias rozdzia³u) warto u¿yæ dedykowanych narzêdzi, które u³atwiaj¹ zastosowanie funkcjonalnoœci wspomnianych technologii. W tym celu w trakcie pracy nad prezentowanych projektem magisterskim, u¿ytych zosta³o kilka narzêdzi, które pozwoli³y skróciæ czas potrzebny na implementacjê aplikacji, przeprowadzenie badañ oraz zagregowanie ich rezultatów.

\subsubsection{Matlab}

Matlab jest to œrodowisko przeznaczone do wykonywania obliczeñ numerycznych, matematycznych oraz symulacyjnych. Pocz¹tkowo Nazwa œrodowiska odnosi siê do s³ów MATrix LABoratory, gdy¿ Matlab przeznaczony by³ pocz¹tkowo do numerycznych obliczeñ macierzowych. Aktualnie aplikacja ta ma zdecydowanie szersze mo¿liwoœci - posiada wiele funkcji bibliotecznych, umo¿liwia ich rozbudowê, a tak¿e definiowanie nowych przez u¿ytkownika. Matlab posiada równie¿ dedykowany jêzyk programowania, czego konsekwencj¹ jest mo¿liwoœæ pisania w pe³ni funkcjonalnych aplikacji pracuj¹cych w opisywanym œrodowisku.
W aspekcie grafiki, Matlab pozwala na rysowanie dwu oraz trójwymiarowych wykresów, a tak¿e wizualizacjê rezultatu obliczeñ w postaci animacji. Istotn¹ kwesti¹ w kontekœcie prezentowanej pracy magisterskiej jest posiadanie przez œrodowisko Matlab terminala, który pozwala na wprowadzanie komend i wykonywanie funkcji. Istnieje mo¿liwoœæ jego samodzielnego uruchomienia oraz po³¹czenia z innymi systemami za poœrednictwem dedykowanych bibliotek, które umo¿liwiaj¹ synchronizacjê Matlaba z aplikacjami napisanymi w technologii .NET, Java czy C++.

\subsubsection{SQL Server Management Studio 17}

W czasie pracy nad aplikacj¹ automatyzuj¹c¹ proces przeprowadzania testów wykorzystano darmowe narzêdzie, którego przeznaczeniem jest zarz¹dzanie baz¹ danych - SQL Server Management Studio 17. Potrzeba u¿ycia narzêdzia wynik³a z istniej¹cej infrastruktury aplikacji, która opiera siê na rozwi¹zaniach Microsoftu. Zastosowane narzêdzie znacznie u³atwi³o pracê i wspomog³o proces projektowania bazy danych dziêki funkcjonalnoœci generowania diagramów, które umo¿liwi³y podgl¹d struktury bazy oraz relacji pomiêdzy poszczególnymi tabelami. Kolejn¹ olbrzymi¹ zalet¹ SQL Management Studio jest mo¿liwoœæ tworzenia zapytañ bazodanowych, które pozwalaj¹ w bardzo elastyczny sposób pogrupowaæ olbrzymie iloœci danych w wybrany przez u¿ytkownika sposób. Umo¿liwia to w krótkim czasie stworzenie statystyk zastosowanych algorytmów, które dynamicznie bêd¹ siê aktualizowa³y wraz z nap³ywem kolejnych danych do bazy.

\subsubsection{Visual Studio 2015}

Visual Studio jest to bardzo rozbudowane œrodowisko deweloperskie firmy Microsoft. Stosowane jest do procesu wytwarzania oprogramowania z graficznym interfejsem u¿ytkownika w technologii WPF, WinForms, Web Sites oraz Xamarin. Visual Studio posiada zaawansowany edytor kodu, który wspiera mechanizm podpowiadania sk³adni kodu - IntelliSense, który mo¿e byæ dodatkowo rozbudowany poprzez dedykowane narzêdzia np. Resharper. Zintegrowany debugger zawarty w œrodowisku Visual Studio umo¿liwia równie¿ analizê programu w czasie jego dzia³ania, co w bardzo ³atwy sposób umo¿liwia odnalezienie potencjalnych b³êdów oraz sprawdzenie poprawnoœci zaimplementowanego rozwi¹zania. Funkcje te wraz z wbudowanym designerem do tworzenia aplikacji WPF oraz narzêdziem do projektowania baz danych umo¿liwi³y skoncentrowanie pracy programistycznej przy jednym narzêdziu, dziêki czemu mo¿liwa by³a znaczna oszczêdnoœæ czasowa w temacie poszukiwañ niezbêdnych narzêdzi i ich integracji. Visual Studio, SQL Server Management Studio 17 oraz zastosowane technologie s¹ wytwarzane przez jedn¹ firmê - Microsoft. Dziêki temu aspektowi ich po³¹czenie i synchronizacja jest bezproblemowa i bardzo szybka.

\subsubsection{Resharper}

Wydajnoœæ pracy w temacie projektów programistycznych jest priorytetem, który bezpoœrednio przek³ada siê na oszczêdnoœæ czasow¹, a co za tym idzie na korzyœci finansowe. Dostêpne s¹ narzêdzia, których przeznaczeniem jest poprawienie efektywnoœci osoby implementuj¹cej aplikacjê poprzez kontrolê pisanego kodu wed³ug zdefiniowanych uprzednio zasad oraz zautomatyzowanie czêsto powtarzanych czynnoœci. Resharper jest to dodatek do œrodowiska Visual Studio, który w znacznym stopniu rozbudowuje dostêpne jego funkcjonalnoœci, u³atwiaj¹c przy tym refaktoryzacjê oraz pisanie kodu. 
Funkcje, które zastosowane byæ mog¹ z poziomu Resharpera mo¿na pogrupowaæ na kilkanaœcie grup, z których jedn¹ z najwa¿niejszych jest modu³, który zajmuje siê inspekcj¹ kodu. W trakcie pisania kodu z uruchomionym w tle Resharperem nastêpuje sprawdzanie w czasie rzeczywistym ponad 2000 zasad, które dotycz¹ jego poprawnoœci i w sytuacji znalezienia niespójnoœci, nastêpuje poinformowanie programisty na poziomie interfejsu Visual Studio o zaistnia³ym b³êdzie wraz z jego szczegó³owym opisem i miejscem wyst¹pienia. Niespójnoœci te mog¹ dotyczyæ dla przyk³adu mo¿liwoœci zast¹pienia czêœci kodu jego wydajniejsz¹ wersj¹, ostrze¿eniem programisty przed fragmentem kodu, który potencjalnie mo¿e spowodowaæ b³êdne dzia³anie ca³ej aplikacji oraz fragmentami martwego kodu.
Kolejn¹ bardzo wa¿n¹ grup¹ funkcji jest funkcjonalnoœæ generowania kodu. W czasie pracy implementacyjnej sporo czynnoœci takich jak edycja nazw czy pisanie nowych klas oraz metod notorycznie siê powtarza. Za pomoc¹ skrótów klawiaturowych, wszystkie powy¿sze akcje Resharper wykona za programistê. Wygeneruje on niezbêdne przy dziedziczeniu interfejsu wszystkie jego sk³adowe, przeniesie dan¹ klasê do odrêbnego pliku oraz automatycznie dokona zamiany wybranej nazwy na inn¹ w obrêbie ca³ej solucji. 
Zaprezentowane funkcje Resharpera wraz z innymi, które dostêpne s¹ do wgl¹du w odnoœniku (TODO: dodac odnosnik), umo¿liwi³y zmniejszenie czasu potrzebnego na implementacjê niezbêdnych w projekcie modu³ów poprzez zminimalizowanie liczby pojawiaj¹cych siê zagro¿eñ we wczesnej fazie implementacji oraz zautomatyzowanie powtarzalnych czynnoœci.  

\subsection{Wykorzystane biblioteki zewnêtrzne}

W trakcie budowy systemu informatycznego zdarzaj¹ siê sytuacje, w których korzysta siê z aplikacji ró¿nych firm, które domyœlnie nie umo¿liwiaj¹ ich po³¹czenia. Problem taki wyst¹pi³ równie¿ w czasie pracy nad prezentowanym projektem magisterskim. U¿ycie narzêdzia innej firmy ni¿ Microsoft, jakim jest Matlab doprowdzi³o do koniecznoœci znalezienia metody jego po³¹czenia ze œrodowiskiem .NET

\subsubsection{Matlab Application Type Library v.1.0}

Matlab Application Type Library w wersji pierwszej jest to otwarta biblioteka przeznaczona dla œrodowiska .NET posiadaj¹ca API umo¿liwiaj¹ce wykonywanie operacji Matlabowych stosuj¹c sk³adniê C\#. Biblioteka ta umo¿liwia odwo³ywanie siê do uprzednio zdefiniowanych w Matlabie funkcji, dostarczaj¹c odpowiednich parametrów oraz odbiera wyniki obliczeñ, które mog¹ byæ dalej przetwarzane bez koniecznoœci manualnego kopiowania danych z aplikacji Matlab. Biblioteka posiada bardzo ogólnie zdefiniowane metody, do prawid³owego wykonania których niezbêdna jest szczegó³owa wiedza, która ograniczona jest jednak przez wzgl¹d na brak dokumentacji. Przy d³u¿szej pracy jest jednak mo¿liwe dojœcie do sposobu skorzystania z zaawansowanych funkcji które dostarcza œrodowisko Matlab. W rozdziale (TODO: dodaj numer rozdzialu) przedstawiono dok³adny sposób przekazywania i odbierania danych pomiêdzy œrodowiskiem Matlab oraz .NET.

\section{Architektura budowanej aplikacji}

Budowanie bazodanowej aplikacji komputerowej ³¹cz¹cej siê z systemem trzecim wymaga szczegó³owej analizy wszystkich elementów, które maj¹ odniesienie do jej architektury. Przez koniecznoœæ budowy dwóch oddzielnych elementów - bazy danych oraz aplikacji desktopowej, analiza ta podzielona zosta³ na czêœæ odwo³uj¹c¹ siê do architektury aplikacji, modelowania bazy danych oraz komunikacji bazy danych z projektem programistycznym oraz komunikacji œrodowiska Matlab z implementowan¹ aplikacj¹. 

\subsection{Architektura aplikacji}

W aspekcie programowania, podobnie jak w innych dziedzinach, w których przeprowadzana jest operacja budowy zadanego elementu, nale¿y dok³adnie zaplanowaæ jego proces. W przedstawianym rozdziale przedstawiony zosta³ opis metodologii, która pozwala na uporz¹dkowanie procesu budowania aplikacji komputerowej wraz z jej odmian¹, która zastosowana zosta³a podczas pracy nad niniejsz¹ prac¹ magistersk¹. W rozdziale (TODO: dodaæ numer) zosta³ równie¿ zawarty szczegó³owy opis poszczególnych elementów ze strony projektu programistycznego, który to jest efektem pracy implementacyjnej.
 
\subsubsection{Wzorce architektoniczne oprogramowania}

Bardzo dobr¹ praktyk¹ programistyczn¹ jest przeprowadzenie procesu budowy aplikacji w taki sposób, aby mo¿liwy by³ efektywny jej rozwój oraz dokonanie w ³atwy sposób zmian w istniej¹cych ju¿ funkcjonalnoœciach. W tym celu budowê aplikacji nale¿y przeprowadzaæ zgodnie z ustalonymi etapami produkcji oprogramowania. Etapy te definiuj¹ obowi¹zek ustalenia wymagañ budowanego systemu oraz okreœlenia jego ogólnej architektury. Czêœæ dotycz¹ca okreœlenia architektury jest niebywale wa¿na poniewa¿ jej zmiana podczas fazy implementacji jest niebywale problematyczna i w wielu przypadkach wrêcz niemo¿liwa bez koniecznoœci powtórnego rozpoczêcia pracy od pocz¹tku. Kolejne etapy maj¹ na celu zrealizowanie zdefiniowanej wczeœniej architektury poprzez zaprogramowanie ka¿dego komponentu oprogramowania wraz ze wszystkim niezbêdnymi wzajemnymi po³¹czeniami, przetestowanie ca³oœci zaimplementowanego systemu, a tak¿e jego uruchomienie oraz zniwelowanie b³êdów, które pojawi³y siê w trakcie jego dzia³ania.
W kontekœcie planowania i budowania architektury systemu bardzo u¿yteczne s¹ wzorce architektoniczne, które to s¹ powszechnymi, sprawdzonymi oraz ogólnie przyjêtymi sposobami rozwi¹zania okreœlonego problemu z zakresu architektury oprogramowania. Definiuj¹ one ogóln¹ strukturê systemu informatycznego, elementy, które wchodz¹ w jego sk³ad oraz zasadê komunikowania siê komponentów pomiêdzy sob¹. Dokonanie wyboru odpowiedniego wzorca jest w du¿ym stopniu zale¿ne od technologii, która stosowana jest w projekcie. W przypadku prezentowanej aplikacji oraz technologii WPF na której bazuje, stosowanym powszechnie wzorcem jest Model View ViewModel (MVVM), który to jest odmian¹ ogólnego wzorca MVC.

\subsubsection{Zastosowany wzorzec architektoniczny – MVVM}

MVVM to wzorzec, który dziêki separacji warstwy logiki biznesowej oraz warstwy prezentacji, pozwala na tworzenie ³atwo testowalnej aplikacji, której fragmenty kodu mog¹ byæ ponownie u¿yte w innych projektach programistycznych. Aplikacje pisane w technologii WPF przy u¿yciu wzorca MVVM umo¿liwiaj¹ równie¿ ich prost¹ rozbudowê, a poprzez obowi¹zek zachowania odpowiedniej struktury kodu, któr¹ owy wzorzec wymusza, zrozumienie kodu przez now¹ osobê jest o wiele prostsze i mniej czasoch³onne ni¿ w przypadków aplikacji pisanych bez ¿adnej ogólnej struktury. MVVM jest to wzorzec, który jest bardzo popularny w gronie programistów skoncentrowanych przy technologii WPF. Powodem tego jest mo¿liwoœæ u¿ycia najwiêkszych zalet tej technologii, takich jak binding (wi¹zania), behavior (zachowania) oraz command (komendy). Struktura kodu aplikacji bazuj¹cej na opisywanym wzorcu, podzielona jest na trzy oddzielne warstwy, których nazwy sk³adaj¹ siê na nazwê wzorca: Model, Widok (View) oraz Model Widoku (ViewModel). Ka¿da z warstwa spe³nia w aplikacji specjalnie okreœlone funkcje i przetwarza dedykowane dla siebie dane. Graficzna prezentacja oraz kierunki przesy³ania danych dostêpna jest do wzgl¹du na rysunku (TODO: dodac numer rysunku).
Warstwa Modelu we wzorcu MVVM jest odpowiedzialna za tak zwan¹ logikê biznesow¹ budowanego systemu. W aplikacji budowanej na potrzeby prezentowanej pracy magisterskiej, warstwa ta zawiera wszystkie klasy, które stworzone zosta³y za pomoc¹ narzêdzia mapowania obiektowo-relacyjnego Entity Framework w celu odwzorowania relacyjnej bazy danych na poziom obiektów dostêpnych w kodzie.
Ka¿da klasa zawarta w czêœci modelu, której dane maj¹ zostaæ wys³ane do warstwy widoku w celu ich wyœwietlenia u¿ytkownikowi zobligowane s¹ do implementacji interfejsu \textit{INotifyPropertyChanged}, który aktywnie wspó³pracuje z wi¹zaniem stosowanym w WPF.
Drug¹ z kolei warstw¹ jest warstwa widoku, której odpowiedzialnoœæ sprowadza siê wy³¹cznie do wyœwietlania danych. Jej rol¹ jest prezentowanie danych w oknie aplikacji, do którego dostêp maj¹ u¿ytkownicy systemu.
Ostatni¹ warstw¹ modelu MVVM jest warstwa ViewModelu, której przeznaczeniem jest poœredniczenie w wymianie danych pomiêdzy modelem oraz widokiem, do którego nie posiada jednak ¿adnej referencji. Elementy widoku odnosz¹ siê do ViewModelu dziêki wspomnianym ju¿ komendom oraz bindingowi. Taki mechanizm zapewnia w pe³ni separacjê warstwy ViewModelu, a co za tym idzie, umo¿liwia pe³ne jego przetestowanie bez ¿adnej zale¿noœci od rzeczywistej warstwy widoku oraz modelu.

\subsubsection{Model aplikacji}

U¿ycie wzorca MVVM w aplikacji implementowanej na potrzeby prezentowanej pracy magisterskiej poskutkowa³o w projekcie programistycznym do powstania obszernej solucji, która sk³ada siê z ponad siedemdziesiêciu plików. Dziêki zaplanowanej strukturze podzia³u elementów na foldery, zachowano porz¹dek, który umo¿liwia szybkie oraz intuicyjne wyszukiwanie potrzebnych sk³adowych aplikacji. Wszelkie pliki klas zosta³y umiejscowione w katalogach nazwanych w sposób adekwatny do ich przeznaczenia, przez co odnalezienie przez programistê szukanego elementu nie przysparza ¿adnych problemów.

\subsubsection*{Managers}

\textit{Managers} jest to katalog zawieraj¹cy klasê menad¿era tworz¹cego i wysy³aj¹cego ¿¹danie przeprowadzenia doœwiadczenia do œrodowiska Matlab. Menad¿er ten za poœrednictwem klas dopasowuj¹cych tworzy ¿¹danie zgodne ze standardem zastosowanej biblioteki opisanej w (TODO dodac alias 4.3.1), wysy³a je do œrodowiska obliczeniowego oraz odbiera rezultaty.

\subsubsection*{Matlab}

Folder \textit{Matlab} ukazany na rysunku (TODO: dodaj rysunek) zawiera pliki funkcji zapisanych w œrodowisku Matlab. Pliki te zawieraj¹ definicjê trzech algorytmów metaheurystycznych oraz wybranych funkcji testowych. Przez fakt na ograniczon¹ funkcjonalnoœæ zastosowanego API, ³¹cz¹cego œrodowisko .NET ze œrodowiskiem Matlab, definicje funkcji testowych oraz algorytmów musia³y znaleŸæ siê w jednym katalogu z powodu braku wsparcia przechodzenia pomiêdzy ró¿nymi katalogami.

\subsubsection*{Model}

Katalog Modelu przedstawiony na obrazu (TODO: dodaæ odnoœnik) zawiera utworzon¹ przez Entity Framework strukturê obiektow¹ relacyjnej bazy danych. Liczba plików, które zawiera uzale¿niona jest bezpoœrednio od liczby tabel, która zastosowana zosta³a w bazie danych. W czasie dzia³añ implementacyjnych nie jest konieczna wiedza o dok³adnej strukturze przedstawianego folderu, a tylko która bazodanowa tabela zawiera jakie dane.

\subsubsection*{Services}

Katalog \textit{Servies} zawiera dwa serwisy stosowane w prezentowanej aplikacji. Pierwszym z nich jest serwis bazy danych który umo¿liwia po³¹czenie siê z fizycznie istniej¹c¹ baz¹ danych. Za pomoc¹ dedykowanych obiektów Entity Frameworka umo¿liwia on zapisywanie do bazy danych rezultatów przeprowadzonych doœwiadczeñ oraz pobieranie niezbêdnych danych dotycz¹cych stosowanych algorytmów oraz funkcji testowych.
Drugim z kolei serwisem jest serwis Matlaba, który przezchowuje obiekty umo¿liwiaj¹ce dwukierunkow¹ komunikacjê ze œrodowiskiem obliczeniowym.

\subsubsection*{Tools}

Katalog narzêdzi, którego graficzna reprezentacja dostêpna jest do zobaczenia na rysunku (TODO: dodaj alias rysunku) jest najbardziej rozbudowanym katalogiem w drzewie solucji. Przez wzgl¹d na jego szerokie zastosowanie posiada on trzy podfoldery, które uœciœlaj¹ definicjê elementów w nich siê znajduj¹cych. Pierwsyzm z nich jest \textit{Parser}, który zawiera t³umacza rezultatów otrzymanych ze œrodowiska obliczeniowego. Przez wzgl¹d na nieuporz¹dkowan¹ formê danych otrzymywanych z Matlaba pojawi³a siê koniecznoœæ ich uporz¹dkowania, bior¹c jednoczeœnie pod wzgl¹d, i¿ rezultaty doœwiadczeñ dla ró¿nych algorytmów oraz ró¿nych funkcji testowych mog¹ posiadaæ inne struktury. Drugi podkatalog to \textit{Utils}, który zawiera dwie bardzo wa¿ne metody dopasowuj¹ce nazwy Matlabowych plików na podstawie wybranego algorytmu metaheurystycznego oraz funkcji testowej. Ostatnim podkatalogiem jest \textit{MatlabContextWrapper}, który zawiera metody u³atwiaj¹ce odwo³anie siê do obiektów komunikacyjnych, które poœrednicz¹ w dwukierunkowym przekazywaniu informacji pomiêdzy œrodowiskami .NET oraz Matlab.

\subsubsection*{View}

Katalog widoku jest katalogiem najwa¿niejszym ze strony u¿ytkownika poniewa¿ zawiera definicjê budowy g³ównego okna aplikacji oraz umiejscowienia wszystkich kontrolek jakie ono zawiera. W tym w³aœnie miejscu wykorzystywany jest opisany w rozdziale (TODO: dodaæ alias 4.1.2 xaml) jêzyk XAML, który pozwala na przeprowadzenie operacji wi¹zañ oraz stosowanie komend.

\subsubsection*{ViewModel}

Ostatni opisywany katalog - \textit{ViewModel} - zawiera pliki dostosowane do pracy ze wzorcem MVVM. Odpowiadaj¹ one na interakcjê u¿ytkownika oraz realizuj¹ akcje dostêpne z poziomu okna aplikacji, w którym pracuje u¿ytkownik. Wa¿nym elementem ze strony programistycznej jest plik \textit{ViewModelLocator}, w którym przeprowadzana jest operacja rejestrowania wszelkich typów zastosowanych w aplikacji. Dziêki temu, mo¿liwe jest skorzystanie ze wzorca wstrzykiwania zale¿noœci, który pozwala na pisanie kodu o luŸniejszych powi¹zaniach, prostszego w testowaniu oraz modyfikacji. (TODO: dodaj odnosnik do di)

\subsection{Architektura bazy danych}

Tematyka projektu dotycz¹ca analizy porównawczej algorytmów metaheurystycznych doprowadzi³a do powstania potrzeby zastosowania œrodowiska bazodanowego, które umo¿liwia przechowywanie oraz agregowanie wyników zautomatyzowanych doœwiadczeñ. W prezentowanym rozdziale opisany zosta³ serwer bazodanowy, który przechowuje instancjê bazy, jego dzia³anie oraz model utworzonej bazy danych.

\subsubsection{Microsoft SQL Server – u¿yty system zarz¹dzania baz¹ danych}

Zastosowanie w projekcie bazy danych wymusi³o obowi¹zek utworzenia oraz uruchomienia serwera bazodanowego. Przez fakt na zastosowane technologie, których opis znajduje siê w rozdziale 4(TODO: dodaæ alias rozdzia³u), u¿yty zosta³ Microsoft SQL Server. Jest to relacyjny system zarz¹dzania baz¹ danych, którego podstawow¹ funkcj¹ jest przechowywanie i przetwarzanie danych na ¿¹danie innych aplikacji, które mog¹ dzia³aæ na tym samym komputerze lub na innym komputerze w sieci LAN czy te¿ WAN. Przydatnym narzêdziem przy pracy z Microsoft SQL Serverem jest dedykowane narzêdzie z graficznym interfejsem u¿ytkownika, który w znacznym stopniu upraszcza korzystanie z funkcji SQL serwera.
W przypadku budowanej aplikacji serwer bazodanowy zosta³ utworzony na maszynie lokalnej, na której dzia³a równie¿ aplikacja automatyzuj¹ca testy. Na potrzeby przeprowadzanych doœwiadczeñ rozwi¹zanie to jest wystarczaj¹ce przez fakt braku koniecznoœci posiadania bardzo szybkiego œrodowiska, które wymaga uiszczenia op³at adekwatnych do rodzaju wykupywanego serwera.

\subsubsection{Budowa bazy danych u¿ytej w projekcie}

Przed rozpoczêciem etapu implementacyjnego oraz po zakoñczeniu analizy dotycz¹cej wyboru wzorca architektonicznego aplikacji, zaprojektowana zosta³a struktura tabel bazodanowych wraz ze ich wszystkimi dostêpnymi kolumnami oraz typami, a tak¿e po³¹czenia i relacje miêdzy nimi. Proces projektowania bazy danych jest procesem bardzo wa¿nym, a jednoczeœnie czêsto bagatelizowanym. W sytuacji nieprzemyœlanego zaprojektowania bazy danych istnieje mo¿liwoœæ pojawienia siê problemu z rozwojem i dodawaniem kolejnych potrzebnych tabel, na których mia³yby operowaæ nowe funkcjonalnoœci aplikacji. Nieprzemyœlana struktura tabel mo¿e doprowadziæ do zbêdnego powielania danych, której konsekwencj¹ bêdzie bardzo szybko powiêkszaj¹cy siê rozmiar bazy danych. Kolejnym efektem Ÿle zaprojektowanej bazy mo¿e byæ spowolniona praca i d³ugie wykonywanie zapytañ. W celu unikniêcia przedstawionych problemów, dokonana zosta³a szczegó³owa analiza wymaganych funkcjonalnoœci oraz danych, które one zwracaj¹. Wykorzystana w budowanej aplikacji baza danych mo¿e zostaæ podzielona na dwa g³ówne sk³adniki - czêœæ s³ownikow¹ zawieraj¹c¹ opisy wybranych algorytmów metaheurystycznych oraz funkcji testowych, a tak¿e czêœæ dotycz¹c¹ przeprowadzanych badañ oraz wyników przez nie otrzymanych.

\subsubsection*{Czêœæ s³ownikowa}

Na s³ownikow¹ czêœæ bazy danych sk³adaj¹ siê trzy tabele, które zawieraj¹ dane wejœciowe niezbêdne w aplikacji: \textit{Alghoritm}, \textit{TestFunction}oraz \textit{ExitFlag}.

Tabela \textit{Alghoritm} (TODO sprawdzic poprawnosc nazwy) jest prost¹ tabel¹ s³ownikow¹ zawieraj¹c¹ identyfikator oraz nazwê algorytmu metaheurystycznego. Lista algorytmów dostêpnych do przetestowania w aplikacji znajduje siê w³aœnie w tej tabeli. Na podstawie nazwy algorytmu, dopasowywana jest jej funkcja Matlabowa, w której tkwi g³ówna logika algorytmu. W celu dodania kolejnego algorytmu, nale¿y dodaæ wpis w opisywanej tabeli oraz wed³ug odpowiedniego schematu dostêpnego do wgl¹du w klasie \textit{FunctionNameMatcher} stworzyæ funkcjê w aplikacji Matlab. Tak utworzony schemat algorytmu nale¿y kolejno dodaæ do warstwy ViewModelu oraz dostosowaæ logikê okna u¿ytkownika do wymaganych przez algorytm parametrów. 

\textit{TestFunction} (TODO sprawdzic poprawnosc nazwy) jest to tabela, która opisuje funkcje testowe na bazie których dokonywane s¹ testy algorytmów. Zawarte w niej s¹ takie informacje jak identyfikator funkcji, jej nazwa, poziom trudnoœci ustalony na bazie stopnia skomplikowania funkcji testowej zaczerpniêty ze (TODO: Ÿród³o do listy algorytmów), odnoœnik do wykresu danej funkcji wraz z informacjami na jej temat, zakres p³aszczyzny w obrêbie której ma byæ poszukiwana wartoœæ minimalna oraz wymiar funkcji czyli liczba zmiennych, z której owa funkcja siê sk³ada. W celu dodania do aplikacji kolejnej funkcji testowej nale¿y tylko dodaæ jej definicjê w opisywanej tabeli oraz utworzyæ plik Matlabowy zawieraj¹cy jej wzór. Nazwa pliku powinna zgadzaæ siê ze schematem zawartym w klasie dopasowuj¹cej - \textit{FunctionNameMatcher}. Tak utworzony algorytm automatycznie bêdzie dostêpny do wyboru z poziomu aplikacji.

Ostatnia tabela z czêœci s³ownikowej bazy danych to tabela \textit{ExitFlag} w której zdefiniowane s¹ numery flag wyjœcia z Matlabowych funkcji oraz ich opis. Przeznaczeniem jej jest uzyskanie informacji dotycz¹cej powodu zakoñczenia pracy danego algorytmu. Powodem tym mo¿e byæ dla przyk³adu osi¹gniêcie maksymalnego za³o¿onego czasu dzia³ania algorytmu, liczby iteracji lub liczby odwo³añ do funkcji testowej.

\subsubsection*{Czêœæ dotycz¹ca przeprowadzonych badañ}

Czêœæ bazy danych odnosz¹ca siê do przeprowadzanych badañ jest czêœci¹ bardziej rozbudowan¹ ni¿ czêœæ s³ownikowa. Zawiera ona wszelkie informacje dotycz¹ce parametrów wejœciowych danego testu oraz rezultaty przeprowadzanych badañ. G³ówn¹ tabel¹, która jest swojego rodzaju trzonem bazy danych jest tabela \textit{Results} (TODO: sprawdz nazwe). Po przeprowadzeniu pojedynczego doœwiadczenia w tabeli tej tworzony jest wpis, który zawiera identyfikatory wierszy odnosz¹ce siê do pozosta³ych tabel, które umo¿liwiaj¹ uzyskanie wszelkich informacji o doœwiadczeniu.

W tabeli \textit{InputParameters} (TODO: sprawdz nazwe) zawarte s¹ informacjê o parametrach wejœciowych algorytmów takich jak maksymalny czas dzia³ania algorytmu, maksymalna liczba iteracji, dopuszczalna liczba odwo³añ do funkcji testowej oraz w zale¿noœci od wybranego algorytmu wielkoœæ roju lub wielkoœæ populacji.

Rezultaty przeprowadzonego badania umiejscawiane s¹ w tabeli \textit{ResultDetail} (TODO: sprawdz nazwe), w której to mo¿na uzyskaæ informacjê na temat liczby przeprowadzonych iteracji, liczby odwo³añ do funkcji testowej, najmniejszej znalezionej wartoœci funkcji, czasu dzia³ania algorytmu oraz informacjê o powodzeniu jego wykonania. Dodatkowym elementem, który przechowywany jest w bazie jest lokalizacja punktu posiadaj¹cego najmniejsz¹ znalezion¹ wartoœæ funkcji. Pocz¹tkowo temat pracy magisterskiej zak³ada³ porównanie algorytmów metaheurystycznych bazuj¹c wy³¹cznie na funkcjach dwóch zmiennych. Lokalizacja najlepszego punktu przechowywana by³a w dwóch kolumnach tabeli \textit{ResultDetails}. Po zmianie wymagañ, które dotyczy³y koniecznoœci obs³u¿enia funkcji wielu zmiennych musia³a nast¹piæ modyfikacja struktury bazy danych. Wartym wspomnienia s¹ tutaj fazy dok³adnej analizy potrzeb, które baza danych ma spe³niaæ oraz proces jej projektowania. Ju¿ na tym etapie jako jedno z ryzyk projektowych za³o¿one zosta³o w³aœnie zmienienie podejœcia do liczby wymiarów funkcji testowych. W celu zapewnienia prawid³owego przetwarzania i przechowywania danych zosta³a w tym celu stworzona nowa tabela - \textit{Points}. Tabela ta jest w relacji wiele do jednego z tabel¹ \textit{ResultDetails} oraz umo¿liwia przechowywanie wartoœci punktu dla ka¿dego wymiaru jako oddzielny wpis. Dla przyk³adu lokalizacja punktu dla funkcji piêciu zmiennych przechowywana bêdzie w postaci piêciu wpisów w omawianej tabeli, z których ka¿dy opisywaæ bêdzie jego lokalizacjê oraz numer wymiaru do którego ma odniesienie.

\subsection{Komunikacja bazy danych z projektem programistycznym}

Umo¿liwienie kontaktu aplikacji z baz¹ dan¹ jest kluczow¹ kwesti¹, która odnosi siê do prawid³owego dzia³ania bazodanowego projektu programistycznego. Bezpieczne, stabilne oraz ci¹g³e po³¹czenie umo¿liwia pozbawione problemów przesy³anie danych z gwarancj¹ ich niezmiennoœci oraz odpowiedni¹ informacj¹ w momencie pojawienia siê b³êdu komunikacyjnego. W technologii .NET, w której implementowana jest aplikacja bazodanowa mo¿liwe jest kilka podejœæ do omawianego zagadnienia. Jednym z nich jest standardowe podejœcie udostêpniane przez ADO.NET oraz nowsze, które dotyczy komunikacji na poziomie obiektów.

\subsubsection{Mapowanie obiektowo-relacyjne}

Mapowanie obiektowo-relacyjne (ang. ORM - Object-Relational Mapping) jest to pojêcie, które dotyczy informatycznego terminu odnosz¹cego siê do wspó³pracy z baz¹ danych przy wykorzystaniu programowania obiektowego. Dok³adniej chodzi tutaj o translacjê danych, które przechowywane s¹ w tabelach bazodanowych w relacyjnej bazie danych na postaæ obiektow¹, która dostêpna jest z poziomu projektu programistycznego. Przedstawiony sposób komunikacji jest sposobem bardzo u¿ytecznym przez wzgl¹d na brak koniecznoœci analizy struktury bazy danych przez programistê oraz umo¿liwienie pobierania oraz zapisu danych z poziomu kodu, unikaj¹c bazodanowego jêzyka zapytañ SQL.
Aplikacje komputerowe, które u¿ywane s¹ przez wielu u¿ytkowników oraz wymagaj¹ pobierania i zapisywania du¿ych iloœci danych czêsto korzystaj¹ z serwerów bazodanowych. Serwery te pozwalaj¹ na przechowywanie danych bez ¿adnych przerw oraz ich szybkie wyszukiwanie, dodawanie oraz edycjê. Aspekt ten jest bardzo trudny do osi¹gniêcia korzystaj¹c wy³¹cznie ze standardowych aplikacji. W technologii .NET, standardowa komunikacja z baz¹ danych przebiega za pomoc¹ protoko³u ADO.NET. Przy jego zastosowaniu, w celu pobrania danych, programista musi za ka¿dym razem po³¹czyæ siê z baz¹ danych, manualnie zapisaæ zapytanie SQL, odebraæ wynik, zapisaæ go w zmiennej oraz zamkn¹æ po³¹czenie. Schemat ten bardzo komplikuje kwestiê utrzymania aplikacji w sytuacji modyfikacji struktury bazy danych. Zapisane przez programistê zapytanie SQL nie jest w ogóle walidowane pod k¹tem poprawnoœci jego formy, a w sytuacji edycji kolumny bazodanowej, nastêpuje obowi¹zek uaktualnienia wszystkich zapytañ, które jej dotyczy³y. Przyk³adowy schemat pracy podczas korzystania z ADO.NET wraz z porównaniem analogicznej operacji w technologii ORM zaprezentowane zosta³o na poziomie kodu Ÿród³owego (TODO: dodaæ numer)

tututu

W implementowanej aplikacji dotycz¹cej prezentowanej pracy magisterskiej, zdecydowano siê przeciwdzia³aæ opisanym problemom, stosuj¹c framework, który w znacznym stopniu u³atwia programiœcie zastosowanie wszystkich operacji na poziomie komunikacji z baz¹ danych.

\subsubsection{Zastosowane narzêdzie ORM – Entity Framework}

Entity Framework jest to dedykowane dla platformy .NET narzêdzie mapowania obiektowo-relacyjnego, którego zadaniem jest wspieranie budowy trójwarstwowych aplikacji bazodanowych. Budowa obiektowego modelu bazy danych w opisywanym narzêdziu mo¿e byæ wykonana na trzy sposoby.

Pierwsz¹ metod¹ jest podejœcie \textit{Database First}, które jest u¿yteczne w sytuacji, w której dostêpna jest dzia³aj¹ca fizycznie baza danych. Korzystaj¹c z dostêpnego w frameworku kreatora, istnieje mo¿liwoœæ okreœlenia lokalizacji bazy oraz poddania jej automatycznemu mapowaniu, w wyniku którego wygenerowane zostaj¹ niezbêdne klasy obiektowego modelu bazy danych.

Kolejnym sposobem jest \textit{Code First}, który pozwala na utworzenie fizycznego modelu bazy danych na podstawie klas napisanych w jêzyku C\# oraz ich odpowiednimi przypisami.

Ostatni¹ metod¹ jest \textit{Model First}, które polega na utworzeniu fizycznego modelu bazy danych pos³uguj¹c siê wbudowanemu w Entity Framework Designerem, który w du¿ym stopniu upraszcza tworzenie w³aœciwoœci oraz encji bazodanowych. Œcie¿ka ta stosowana jest, gdy posiadany jest wy³¹cznie sam schemat bazy danych. Ze zbudowanego modelu nastêpuje wygenerowanie fizycznego modelu bazy danych jak i równie¿ klas, które reprezentuj¹ model obiektowy. Sposób ten zosta³ zastosowany w prezentowanej pracy magisterskiej. Po analizie wymagañ i utworzeniu schematu bazy danych, zosta³ on przeniesiony na poziom Designera opisywanego frameworka, który automatycznie stworzy³ skrypt napisany w jêzyku SQL po wykonaniu którego utworzony zosta³ fizyczny model bazy danych, a tak¿e wygenerowa³ wszystkie niezbêdne klasy reprezentuj¹ce model obiektowy zadanego schematu bazy.

\subsection{Komunikacja Matlaba z projektem programistycznym}

Poprawne skomunikowanie aplikacji bazodanowej ze œrodowiskiem obliczeniowym Matlab by³o najtrudniejsz¹ czêœci¹ podczas ca³ej pracy implementacyjnej. Podczas tworzenia architektury budowanej aplikacji, poszukiwany by³ efektywny sposób komunikacji œrodowiska .NET ze œrodowiskiem obliczeniowym Matlab. Przez fakt tego, i¿ systemy te utworzone zosta³y przez ró¿nych producentów, nie ma prostego sposobu na ich sprzê¿enie. Poszukiwania doprowadzi³y do zastosowania biblioteki dedykowanej dla œrodowiska .NET opisanej w rozdziale (TODO: dodaj alias rozdzia³u), która ³¹czy siê z poœrednicz¹cym serwerem Matlaba. Serwer ten nie jest domyœlnie dodawany przy instalacji œrodowiska obliczeniowego, dlatego te¿ nachodzi koniecznoœæ jego dodatkowego doinstalowania. Biblioteka umo¿liwia stworzenie ¿¹dania na poziomie C\#, które nastêpnie przekazywane jest do serwera poœrednicz¹cego t³umacz¹cego ¿¹danie na jêzyk Matlaba. ¯¹danie te jest  wykonywane przez œrodowisko obliczeniowe, a jego rezultat analogiczn¹ œcie¿k¹ jest przekazywany do aplikacji bazodanowej. Sporym problemem okaza³o siê prawid³owe tworzenie ¿¹dañ przez fakt na bardzo ograniczon¹ dokumentacjê biblioteki i ma³¹ liczbê przyk³adów. Na podstawie metody prób i b³êdów uda³o siê jednak utworzyæ prawid³owy typ ¿¹dañ oraz w sposób w³aœciwy dokonywaæ odbioru ich odpowiedzi. ¯¹danie w kodzie Ÿród³owym numer (TODO: dodaæ alias kodu oraz kod metody wykonujacej ¿¹danie) prezentuje sposób wykonania pojedynczego doœwiadczenia dotycz¹cego algorytmu symulowanego wy¿arzania, natomiast kod Ÿród³owy numer (TODO: dodaæ alias kodu oraz kod metody parsujacej wynik) ukazuje sposób przetwarzania otrzymanej odpowiedzi.

\section{Badania eksperymentalne}

Ca³y proces pocz¹wszy od pomys³u automatyzacji przeprowadzanych badañ zawarty w rozdziale (TODO: rozdz 3), przez analizê rozwi¹zañ technologicznych opisanych w rozdziale (TODO: dodac alias rozdzialu 4), po budowê architektury oraz samej aplikacji bazodanowej ujêty w rozdziale (TODO: dodac rozdz 5) mia³ za zadanie u³atwiæ przeprowadzenie eksperymentalnych badañ porównawczych wybranych algorytmów metaheurystycznych. W obecnym rozdziale przedstawiony zosta³ opis metod porównawczych, a tak¿e  samych badañ doœwiadczalnych wraz z ich zagregowanymi wynikami zawartymi w (TODO: dodac alias 6.3)

\subsection{Metody porównawcze wybranych algorytmów}

W celu zrównania szans ka¿dego z porównywanych algorytmów, wszystkie przeprowadzane testy dokonane zosta³y na tej samej maszynie obliczeniowej przy tych samych warunkach obci¹¿eniowych systemu. Pierwszym kryterium porównawczym by³ maksymalny czas, w którym algorytm poszukuje najlepszego rezultatu. Parametr ten bierze pod uwagê kilka ró¿nych ustalonych wartoœci (TODO: podaæ czasy doœwiadczeñ) dla których przeprowadzana zosta³a próbka doœwiadczeñ, z których wartoœci œrednie zosta³y zestawione i porównane w obrêbie wszystkich algorytmów oraz funkcji testowych. Drugim kryterium porównawczym by³a liczba odwo³añ algorytmu do zadanej funkcji testowej. W kryterium tym porównane zosta³y, w sposób analogiczny jak w kryterium pierwszym, rezultaty otrzymane przez algorytmy przy takim za³o¿eniu, i¿ mog³y one wyliczyæ wartoœæ funkcji testowej okreœlon¹ liczbê razy.

\subsection{Opis przeprowadzonych badañ}

\subsubsection{Skalowanie algorytmów}

Przez wzgl¹d na du¿¹ liczbê parametrów ka¿dego porównywanego algorytmu heurystycznego, zdecydowano siê dokonaæ ich dostrojenia przed przeprowadzeniem zaplanowanych badañ. Na bazie wybranych funkcji testowych wykonano liczne testy, na bazie których wybrano parametry, dla których uzyskano najlepsze rezultaty. Dla algorytmu symulowanego wy¿arzania jako metoda sch³adzaj¹ca, wybrana zosta³a standardowa funkcja
\begin{equation}
NowaTemperatura = ObecnaTemperatura * 0.95^k
\end{equation}
, gdzie \textit{k} jest numerem iteracji od wy¿arzenia. Uwzglêdniaj¹c fakt du¿ej liczby iteracji, któr¹ algorytm mo¿e wykonaæ podczas testów, zdecydowano siê wprowadziæ mo¿liwoœæ wyst¹pienia operacji ponownego wy¿arzenia (ang. reannealing), w czasie której algorytm ponownie ustala temperaturê na domyœln¹ wartoœæ 100 i kontynuuje pracê. Wartoœæ parametru ponownego wy¿arzania ustalona zosta³a na poziomie 40 i definiuje liczbê punktów, które algorytm ma obowi¹zek zaakceptowaæ przed wyst¹pieniem ponownego wy¿arzenia.
W metodzie roju cz¹stek domyœlne parametry wzoru (TODO: numer wzoru 1) zawartego w rozdziale (todo: alias 2.2.1) ustalone zosta³y na nastêpuj¹ce wartoœci:
$W = 0.6$, $c_1 = c_2 = 0.75$.
Algorytm genetyczny z kolei wymaga³ najwiêkszej iloœci testów skaluj¹cych przez fakt posiadania najwiêkszej liczby parametrów. Na ich postawie wybrano metodê ruletki jako metodê selekcji, zastêpowanie elitarne o wielkoœci elity równej $0.05*WielkoœæPopulacji$ jako metodê wymiany pokoleñ oraz metodê krzy¿owania dwudzielnego.

\subsubsection{Przeprowadzenie doœwiadczeñ w zaimplementowanym œrodowisku testowym}

W zaimplementowanej aplikacji dla ka¿dego opisanego w (TODO: alias rozdzialu wyzej) kryterium, umieszczane zosta³y ustalone wartoœci parametrów, po czym przeprowadzana by³a operacja uruchomienia systemu. Dla kryterium maksymalnego czasu, w którym algorytmy poszukuj¹ globalnego minimum funkcji, doœwiadczenia wykonywane zosta³y dla zakresu od jednej do piêciu sekund, z jednosekundowym interwa³em. Liczba testów dla ka¿dej wartoœci z ustalonego zakresu ustalona zosta³a na poziomie stu prób. Pozosta³e parametry, takie jak maksymalna liczba iteracji oraz odwo³añ do funkcji wraz z maksymaln¹ liczb¹ iteracji bez poprawy wyniku, ustalone zosta³y na niemo¿liw¹ do osi¹gniêcia wartoœæ 999999. Spowodowane jest to tym, i¿ jednym warunkiem stopu w przedstawianej metodzie porównawczej jest maksymalny ustalony czas dzia³ania algorytmu.
W przypadku algorytmu genetycznego oraz roju cz¹stek dodatkowo przeprowadzone zosta³y doœwiadczenia dla ró¿nych wielkoœci populacji i roju, dziêki czemu mo¿liwa do wykonania by³a analiza wp³ywu tych parametrów na otrzymane rezultaty.
Przeprowadzenie badañ dotycz¹cych kryterium maksymalnej liczby odwo³añ do funkcji testowej przebiega³o w sposób analogiczny, z t¹ ró¿nic¹, i¿ niemo¿liw¹ do osi¹gniêcia wartoœci¹ 999999 zosta³ objêty maksymalny czas poszukiwañ, który w opisywanym kryterium nie jest brany pod uwagê. Dla kryterium tego maksymalna liczba odwo³añ do funkcji ustalona zosta³a na wartoœci: 1000, 2000, 3000, 4000, 5000, 6000.

\subsection{Wyniki doœwiadczeñ dla zadanych funkcji testowych}



\subsubsection{Funkcja Bohachevsky’ego 1}
\subsubsection{Funkcja Colville'a}
\subsubsection{Funkcja Rosenbrocka}
\subsubsection{Funkcja Eggholdera }
\subsubsection{Funkcja Griewanka}
\subsubsection{Funkcja Ackley'a}
\section{Wnioski}
\section*{Podsumowanie}

\end{document}
