\documentclass[twoside]{projektMagisterski}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{xcolor, colortbl}
\usepackage{booktabs}
\usepackage{array}
\usepackage{float}
\restylefloat{table}
\definecolor{red}{rgb}{0.98,0.65,0.65}
\definecolor{green}{rgb}{0.92,0.94,0.87}
\usepackage{array}
\usepackage{tabulary}
\newcolumntype{k}[1]{>{\centering\arraybackslash}p{#1}}
\setlength{\arrayrulewidth}{1.5\arrayrulewidth}% 50% thicker

\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}

\usepackage{listings}

\renewcommand{\lstlistingname}{Kod Ÿród³owy}
\renewcommand\lstlistlistingname{Kody Ÿród³owe}
\renewcommand*{\refname}{Bibliografia}

\lstset{language=[Sharp]C,
captionpos=b,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
morekeywords={partial, var, value, get, set},
keywordstyle=\color{bluekeywords},
stringstyle=\color{redstrings},
basicstyle=\ttfamily\small
}

%\drukJednostronny

\title{Analiza porównawcza algorytmów metaheurystycznych do rozwi¹zywania wybranego problemu optymalizacyjnego}
\promotor{dr in¿. Henryk Josiñski}


\autor{Sebastian Nalepka}{111111}
	


%\NumeryNaPoczatku
%% numeracja wzorów tu w³¹czona typu (1.2.3), ta druga to typu (1.2), domyœlnie typu (1)
%\subsectionWzory
% \sectionWzory  

%\rozdzialy

%% wy³¹czenie wyjaœnieñ:
\bezWyjasnien

%% standardowe komendy \newtheorem  dzia³aj¹ jak woryginale


\begin{document}

W otaczaj¹cym nas œwiecie obecnych jest wiele problemów, z którymi zmagaj¹ siê ludzie. Czêœæ z nich jest problemami prostymi, do rozwi¹zania których wystarczy wy³¹cznie niedu¿y nak³ad czasu. Istniej¹ jednak problemy trudniejsze, które wymagaj¹ d³ugotrwa³ych przemyœleñ i obliczeñ, pomimo których nie zawsze otrzymujemy najlepsze rozwi¹zanie. Do prostych problemów mo¿emy zaliczyæ codzienne decyzje podejmowane przez ka¿dego cz³owieka. Dla przyk³adu, jeœli chcemy dojechaæ z punktu $A$ do punktu $B$ komunikacj¹ miejsk¹, wystarczaj¹ce bêdzie sprawdzenie rozk³adu jazdy i wybranie po³¹czenia, które bêdzie pasowa³o nam w kontekœcie godziny przyjazdu na dane miejsce. Przedstawiony problem posiada inn¹ skalê trudnoœci ze strony przewoŸnika. Wyznaczenie optymalnych tras przewozowych dla okreœlonej liczby œrodków transportu, w celu obs³u¿enia danego zbioru klientów, którzy rozlokowani s¹ w ró¿nych punktach, jest kwesti¹ bardzo skomplikowan¹. Znalezienie optymalnych tras, które umo¿liwi¹ przetransportowanie jak najwiêkszej liczby osób w celu zmaksymalizowania zysku, przy zachowaniu mo¿liwie najkrótszych tras, których zamys³em jest minimalizowanie kosztów poniesionych z transportem, jest z³o¿onym problemem, znanym jako jedna z odmian problemu marszrutyzacji, który jest z kolei rozwiniêciem bardzo popularnego problemu komiwoja¿era \cite{ProblemKomiwojazera}. Problem ten polega na znalezieniu najkrótszej drogi ³¹cz¹cej wszystkie zdefiniowane uprzednio punkty, zaczynaj¹c i koñcz¹c w tym samym miejscu. Problemy, do rozwi¹zania których potrzebne s¹ ogromne nak³ady obliczeniowe, definiowane s¹ jako problemy optymalizacyjne. W problemach takich liczba mo¿liwych rozwi¹zañ w przestrzeni poszukiwañ z regu³y jest tak du¿a, ¿e niemo¿liwe jest w skoñczonym czasie zastosowanie przeszukiwania wyczerpuj¹cego w celu znalezienia najlepszego z nich. 

\subsection*{Cel pracy}

Celem pracy jest dokonanie analizy porównawczej algorytmu symulowanego wy¿arzania, algorytmu genetycznego oraz metody optymalizacji rojem cz¹stek za pomoc¹ zaimplementowanej dedykowanej aplikacji bazodanowej, której przeznaczeniem jest zautomatyzowanie procesu szukania minimum globalnego dla zadanych funkcji testowych.

\subsection*{Zawartoœæ pracy}

Przygotowana czêœæ opisowa pracy sk³ada siê ze wstêpu, szeœciu rozdzia³ów oraz podsumowania. W rozdziale pierwszym przedstawiony zosta³ wybór problemu optymalizacyjnego wraz z jego opisem oraz list¹ funkcji testowych, które u¿yte zosta³y do przeprowadzenia badañ. Rozdzia³ drugi przedstawia mo¿liwe sposoby rozwi¹zania wybranego problemu optymalizacyjnego wraz z opisem u¿ytych algorytmów metaheurystycznych. Na bazie dwóch pierwszych rozdzia³ów opisany zosta³ w rozdziale trzecim projekt automatyzacji przeprowadzanych doœwiadczeñ, na podstawie którego bazowa³a budowana aplikacja. Kolejny rozdzia³ to zastosowane rozwi¹zania technologiczne oraz opis wykorzystanych technologii, bibliotek zewnêtrznych, a tak¿e narzêdzi. Na ich podstawie utworzona zosta³a architektura aplikacji bazodanowej, której specyfikacja umiejscowiona zosta³a w rozdziale pi¹tym. Kolejny rozdzia³ prezentuje ju¿ œciœle aspekt badawczy. Zawiera on opis metod porównawczych oraz przeprowadzonych badañ, a tak¿e wyniki doœwiadczeñ dla u¿ytych funkcji testowych wraz z ich podsumowaniem.

Do czêœci opisowej pracy magisterskiej do³¹czona zosta³a p³yta CD zawieraj¹ca pliki umo¿liwiaj¹ce uruchomienie zaimplementowanej aplikacji bazodanowej oraz solucjê, w której umiejscowiony jest kod aplikacji. Opisywany noœnik posiada dodatkowo plik PDF z treœci¹ pracy oraz plik instrukcji, w którym znajduj¹ siê informacje dotycz¹ce sposobu konfiguracji aplikacji oraz odnoœniki do oprogramowania, którego instalacja jest konieczna w celu prawid³owego dzia³ania zaimplementowanego programu.

\section{Wybór badanego problemu optymalizacji}

\subsection{Podstawowe pojêcia optymalizacji}

Temat optymalizacji jest bardzo obszernym tematem, w ramach opisu którego wystêpuje kilka okreœleñ, których definicje warto wyjaœniæ. Podstawowym pojêciem jest \textit{problem optymalizacji}, który to mo¿e zostaæ opisany jako próba znalezienia wartoœci zmiennej $x$ zawartej w danym \textit{zbiorze $X$}, dla której ustalona funkcja $f(x)$ przyjmuje najkorzystniejsz¹ wartoœæ. Funkcja ta nazywana jest \textit{funkcj¹ celu} i za zadanie ma zmierzenie wartoœci celu, jaki ma zostaæ osi¹gniêty. W kontekœcie prezentowanej pracy magisterskiej celem takim jest uzyskanie najmniejszej mo¿liwej wartoœci danej funkcji, czyli jej minimum globalnego. \textit{Zbiór $X$} z kolei jest wyznaczony przez zbiór ograniczeñ problemu, który w temacie minimalizacji funkcji jest ustalon¹ dziedzin¹ danej funkcji, czyli zbiorem wszystkich jej argumentów. Zbiór ten nazywany jest równie¿ \textit{przestrzeni¹ poszukiwañ lub przestrzeni¹ rozwi¹zañ}.

\subsection{Opis minimalizacji funkcji ci¹g³ych wielu zmiennych}
\label{dzial:OpisMinimalizacjiFunkcjiCiaglych}

W prezentowanej pracy dokonano porównania algorytmów metaheurystycznych odnosz¹c siê do problemu minimalizacji funkcji wielu zmiennych. Problem ten polega na znalezieniu minimum globalnego funkcji poprzez systematyczne wybieranie parametrów wejœciowych z dozwolonego zakresu i obliczaniu dla nich wartoœci funkcji. Trudnoœæ problemu sprowadza siê do wielkoœci przestrzeni przeszukiwania. Traktuj¹c problem jako czysto matematyczny, funkcja \textit{n} zmiennych posiada nieskoñczenie wiele wartoœci w ka¿dym wymiarze. Mamy wiêc nieskoñczenie wielk¹ przestrzeñ poszukiwañ. Bior¹c jednak pod wzgl¹d aspekt technologiczny i to, i¿ komputery bazuj¹ na danych skoñczonych, mo¿na w prosty sposób przedstawiæ skalê trudnoœci. W czasie implementacji algorytmu, którego celem jest znalezienie minimum globalnego funkcji, nale¿y wzi¹æ pod uwagê dostêpn¹ dok³adnoœæ obliczeniow¹ maszyny. Zak³adaj¹c, i¿ dok³adnoœæ ta wynosi osiem miejsc po przecinku, ka¿da zmienna ograniczona w przedziale $[0,100]$ mo¿e przyj¹æ $100*10^8$ ró¿nych wartoœci. Ju¿ dla funkcji dwóch zmiennych, wielkoœæ przestrzeni przeszukiwania wynosi $(100*10^8)^2 = 10^{20}$.

\subsection{Funkcje testowe}
\label{dzial:FunkcjeTestowe}

Problem minimalizacji funkcji ci¹g³ych bardzo dobrze nadaje siê do porównania algorytmów metaheurystycznych przez wzgl¹d na powszechnie dostêpne funkcje testowe. Funkcje te posiadaj¹ pewny specyficzny element, dziêki któremu mo¿liwe jest porównanie wyników otrzymanych przez dany algorytm. Element ten to znajomoœæ minimum globalnego dla danej funkcji testowej. Dziêki znajomoœci wartoœci najlepszej (najmniejszej) dla danej funkcji wiadomo, jak szybko oraz czy w ogóle badany algorytm znalaz³ najlepsze mo¿liwe rozwi¹zanie. Posiadaj¹c ten punkt odniesienia mo¿na zestawiæ otrzymane rezultaty wszystkich algorytmów pod k¹tem czasowym lub liczby wyliczeñ wartoœci funkcji dla ustalonych przez algorytm punktów.

Do analizy wybranych zosta³o szeœæ funkcji testowych, podczas doboru których wziêto pod uwagê stopieñ ich skomplikowania. Funkcje te zosta³y wybrane z listy zawartej w artykule \cite{TestFunctionsForOpt} oraz w  \cite{RankingFunkcjiTestowych} uwzglêdniaj¹c ró¿n¹ liczbê wymiarów oraz skalê ich trudnoœci. Ka¿da z funkcji posiada specyficzne w³aœciwoœci, które zostan¹ wziête pod uwagê podczas porównania rezultatów algorytmów heurystycznych.

\subsubsection{Funkcja Bohachevsky’ego I}

Funkcja Bohachevsky'ego I jest stosunkowo prost¹ do minimalizacji funkcja dwóch zmiennych, której wykres przedstawiony na rysunku \ref{wykres:img_boha} przybiera kszta³t ³uku. Z regu³y jest ona badana w zakresie $x_i \in[-100,100]$ dla $i=1,2$. W przedstawianej pracy magisterskiej granice te zosta³y jednak dwukrotnie powiêkszone i wynosz¹ $[-200,200]$. Wed³ug doœwiadczeñ przeprowadzonych w \cite{RankingFunkcjiTestowych}, $81.75\%$ prób zakoñczonych zosta³o znalezieniem minimum globalnego, które dla funkcji Bohachevsky'ego I wynosi $0$ w punkcie $x=(0,0)$.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img_boha1.png}
    $f(x)=x^{2}_1+2x^{2}_2-0.3cos(3\pi x_1)-0.4cos(4\pi x_2)+0.7$
    \caption{Wykres oraz wzór funkcji Bohachevsky'ego I dwóch zmiennych, Ÿród³o: https://www.sfu.ca/\textasciitilde ssurjano/boha.html}
    \label{wykres:img_boha}
\end{figure} 

\subsubsection{Funkcja Colville'a}

Jest to funkcja czterech zmiennych, która posiada jedno minimum globalne o wartoœci $0$ dla punktu $x=(1,1,1,1)$ oraz analizowana jest zazwyczaj na hiperszeœcianie $x_i\in[-200,200]$ dla $i=1,2,3,4$. Wed³ug danych zawartych w \cite{RankingFunkcjiTestowych}, jest to funkcja trudniejsza w minimalizacji od funkcji Bohachevsky'ego I, której procentowy sukces dotycz¹cy znalezienia minimum globalnego wyniós³ $72.00\%$. 
\newline
Wzór funkcji Colville'a: 
\newline
$f(x)=100(x^{2}_1-x_2)^{2}+(x_1-1)^{2}+(x_3-1)^{2}+90(x^{2}_3-x_4)^{2}+10.1((x_2-1)^{2}+(x_4-1)^{2})+19.8(x_2-1)(x_4-1)$ 

\subsubsection{Funkcja Ackleya}

Funkcja Ackleya jest popularn¹ funkcj¹ dla testów optymalizacyjnych algorytmów. W swojej dwuwymiarowej postaci, któr¹ ukazano na rysunku \ref{wykres:img_ack}, charakteryzuje siê stosunkowo p³askim obszarem zewnêtrznym i du¿ym otworem w centrum. Funkcja stwarza ryzyko dla algorytmów optymalizacyjnych poprzez mo¿liwoœæ zatrzymania siê w jednym z licznych lokalnych minimów. Istnieje mo¿liwoœæ rozszerzenia funkcji Ackleya na wiele wymiarów, co te¿ uczyniono w prezentowanej pracy magisterskiej, w której rozpatrywana jest ona dla czterech zmiennych. Minimum globalne umiejscowione jest w punkcie $x=(0,0,0,0)$ i jego wartoœæ wynosi $0$. Dziedzina funkcji analizowana bêdzie z kolei w przedziale $x_i\in[-150,150]$ dla $i=1,2,3,4$. Dla wspomnianych ju¿ testów, których wyniki opublikowano w pracy \cite{RankingFunkcjiTestowych}, procentowy sukces znalezienia minimum globalnego wyniós³ $48.25\%$.
 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img_ack.png}
    $f(x)=-a\exp(-b \sqrt{\frac{1}{d} \sum_{i=1}^d x^{2}_i}-\exp(\frac{1}{d} \sum_{i=1}^d cos(cx_i))+a+\exp(1)
    \newline a=20, b=0.2,c=2\pi$
    \caption{Wykres funkcji Ackleya dla dwóch zmiennych oraz ogólny wzór funkcji, Ÿród³o: https://www.sfu.ca/\textasciitilde ssurjano/ackley.html}
    \label{wykres:img_ack}
\end{figure} 
\newpage
\subsubsection{Funkcja Rosenbrocka}

Funkcja Rosenbrocka jest to niewypuk³a funkcja, która jest bardzo popularna w kontekœcie optymalizacji jako test dla algorytmów optymalizacyjnych. Nazywana jest równie¿ przez wzgl¹d na swój kszta³t \textit{"Funkcj¹ Bananow¹ Rosenbrocka"} albo \textit{"Dolin¹ Rosenbrocka"} \cite{DolinaRosenbrocka}. Funkcja Rosenbrocka powszechnie jest stosowana w kontekœcie optymalizacji funkcji dwóch zmiennych. Istnieje jednak mo¿liwoœæ rozszerzenia jej do wielu wymiarów. W prezentowanej pracy magisterskiej rozpatrywana jest funkcja Rosenbrocka czterech zmiennych, której minimum globalne mieœci siê w punkcie $x=(1,1,1,1)$ i wynosi $0$. Ustalon¹ dziedzin¹ funkcji jest $x_i\in[-200,200]$ dla $i=1,2,3,4$. Opisywana funkcja Rosenbrocka jest funkcj¹ trudn¹ do minimalizacji i wed³ug wyników testów zawartych w \cite{RankingFunkcjiTestowych}, procentowy sukces znalezienia minimum globalnego wyniós³ tylko $8,42\%$.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img_ros.png}
    $f(x)=\sum_{i=1}^{d-1}[100(x_{i+1}-x^{2}_i)^2+(x_i-1)^2]$
    \caption{Wykres funkcji Rosenbrocka dla dwóch zmiennych oraz ogólny wzór funkcji, Ÿród³o: https://www.sfu.ca/\textasciitilde ssurjano/rosen.html}
    \label{wykres:img_ros}
\end{figure} 
  
\subsubsection{Funkcja Eggholdera}

Kolejn¹ wybran¹ funkcj¹ zosta³a dwuwymiarowa funkcja Eggholdera. Jest to funkcja, której graficzna reprezentacja pokazana na rysunku \ref{wykres:img_egg} przypomina pasmo górskie z licznymi dolinami. Jest to funkcja trudna do optymalizacji przez wzgl¹d na licznie wystêpuj¹ce minima lokalne. Dziedzina funkcji powszechnie rozpatrywana jest w przedziale $x_i\in[-512,512]$ dla $i=1,2$. Minimum globalne znajduje siê w punkcie $x=(512,404.2319)$ i wynosi $-959.6407$. Przez wzgl¹d na jego nietypowe po³o¿enie i wspomniane ju¿ liczne minima lokalne, wy³¹cznie $18.92\%$ testów zawartych w \cite{RankingFunkcjiTestowych} zakoñczy³o siê jego znalezieniem.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img_egg.png}
    $f(x)=-(x_2+47)\sin(\sqrt{|x_2+\frac{x_1}{2}+47|})-x_1\sin(\sqrt{|x_1-(x_2+47)|})$
    \caption{Wykres oraz wzór funkcji Eggholdera dwóch zmiennych, Ÿród³o: https://www.sfu.ca/\textasciitilde ssurjano/egg.html}
    \label{wykres:img_egg}
\end{figure} 

\subsubsection{Funkcja Griewanka}

Ostatni¹ wybran¹ do testów funkcj¹ jest funkcja Griewanka, której minimum globalne znalezione zosta³o w tylko $6.08\%$ testów zawartych w \cite{RankingFunkcjiTestowych}. Jest to funkcja posiadaj¹ca bardzo du¿o regularnie rozmieszczonych minimów lokalnych, które utrudniaj¹ znalezienie globalnego minimum znajduj¹cego siê w punkcie $x=(0,...,0)$, dla którego wartoœæ funkcji wynosi $0$. Opisywana funkcja jest funkcj¹ wielowymiarow¹, która w prezentowanej pracy magisterskiej zastosowana zosta³a jako funkcja testowa trzech zmiennych o dziedzinie $x_i\in[-200,200]$ dla $i=1,2,3$. Na rysunku \ref{wykres:img_gri} zaprezentowano opisywan¹ funkcjê w postaci dwuwymiarowej, w której mo¿na dostrzec liczne minima globalne oraz ich regularne rozmieszczenie.
\newline

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img_gri.png}
    $f(x)=\sum_{i=1}^d\frac{x^{2}_i}{4000}-\prod_{i=1}^{d}\cos(\frac{x_i}{\sqrt{i}})+1$
    \caption{Wykres funkcji Griewanka dla dwóch zmiennych oraz ogólny wzór funkcji, Ÿród³o: https://www.sfu.ca/\textasciitilde ssurjano/gri.html}
    \label{wykres:img_gri}
\end{figure} 

\section{Metody rozwi¹zania wybranego problemu optymalizacji}

\subsection{Algorytmy dok³adne}
\label{dzial:AlgorytmyDokladne}

Klasycznym podejœciem do znalezienia minimalnej wartoœci zadanej funkcji testowej jest próba porównania wartoœci funkcji dla ka¿dych mo¿liwych parametrów wejœciowych i wybrania w ten sposób najlepszego rozwi¹zania. W rzeczywistoœci jednak takie rozwi¹zanie nie jest praktyczne przez wzgl¹d na olbrzymi¹ mo¿liw¹ liczbê takich parametrów. Jak ju¿ wspomniano w podpunkcie \ref{dzial:OpisMinimalizacjiFunkcjiCiaglych}, liczba rozwi¹zañ dla funkcji ograniczonej ju¿ do dwóch zmiennych mo¿e siêgaæ wartoœci $10^{20}$, a w przypadku trzech zmiennych – $10^{30}$. Zak³adaj¹c, i¿ mo¿liwe by by³o wyliczenie miliarda wartoœci funkcji na sekundê, to w godzinê wartoœæ ta wynosi³aby  $3.6*10^{12}$, a w rok oko³o $3.2*10^{16}$. Wyliczenie $10^{20}$ wartoœci funkcji trwa³oby oko³o 3171 lat. Widaæ wiêc, ¿e liczba kombinacji jest tak du¿a, i¿ podejœcie to jest niemo¿liwe do wykonania w akceptowalnym czasie.

\subsection{Metaheurystyki optymalizacyjne}

Analizuj¹c podejœcie z podpunktu \ref{dzial:AlgorytmyDokladne} mo¿e przyjœæ na myœl sposób, który polegaæ bêdzie na wyliczaniu wartoœci funkcji dla wybranych wartoœci argumentów. Sk¹d jednak wiadomo, które punkty wybraæ? Na podstawie czego bazowaæ? W przypadku problemów, w których przez wzgl¹d na czas niemo¿liwe jest dojœcie do jednoznacznego rozwi¹zania, na ratunek przychodz¹ algorytmy heurystyczne, które umo¿liwiaj¹ skrócenie czasu obliczeñ. Cen¹, któr¹ trzeba jednak za to zap³aciæ, jest mo¿liwoœæ otrzymania rozwi¹zania gorszego od rozwi¹zania najlepszego. Samo pojêcie heurystyki pochodzi od greckiego s³owa \textit{heuresis}, które oznacza \textit{"odnaleŸæ"} \cite{HeurystykaZGreki}. Metody heurystyczne polegaj¹ na u¿yciu informacji, które uzyskane na drodze badania danego problemu umo¿liwiaj¹ jego rozwi¹zanie lub zbli¿enie siê do poprawnej odpowiedzi. Podejœcie heurystyczne stosowane mo¿e byæ w sposób piêtrowy, tworz¹c metaheurystyki. Metaheurystyka jest to ogólny algorytm do rozwi¹zywania problemów obliczeniowych, który inspiracjê czêsto bierze z mechanizmów biologicznych lub fizycznych. Okreœlenie to oznacza tak zwan¹ heurystykê wy¿szego poziomu \cite{HeurystykaWyzszegoPoziomu}, co wynika z faktu, i¿ algorytmy tego typu bezpoœrednio nie rozwi¹zuj¹ ¿adnego problemu, a wy³¹cznie podaj¹ metodê na utworzenie odpowiedniego algorytmu. 

\subsubsection{Metoda optymalizacji rojem cz¹stek}
\label{dzial:MetodaOptymalizacjiRojemCzastek}

Metoda optymalizacji rojem cz¹stek (PSO – Particle Swarm Optimization) jest przyk³adem optymalizacji z kategorii metod inteligencji stadnej. Powsta³a ona w wyniku inspiracji biologicznej, której Ÿród³em by³ uk³ad lotu stada ptaków tworzony w celu znalezienia po¿ywienia lub gniazda oraz unikniêcia drapie¿ników. Zastosowanie prostych zasad umo¿liwia ptakom zsynchronizowany oraz bezkolizyjnych ruch, który daje efekt podobny do zachowania jednego organizmu. Ruch stada ptaków, czy ³awicy ryb jest wypadkow¹ dzia³ania wszystkich osobników i koncentruje siê na utrzymaniu optymalnego dystansu od swoich s¹siadów, przy jednoczesnym pod¹¿aniu za liderem. Badania nad optymalizacj¹ rojem cz¹stek zapocz¹tkowano od próby graficznej symulacji zachowañ takich grup \cite{PSOOgolneInfo}. Bardzo szybko okaza³o siê, i¿ stworzony matematyczny model mo¿e byæ równie¿ zastosowany jako metoda optymalizacyjna.
W optymalizacji rojem cz¹stek, rozwi¹zania (cz¹stki) wspó³pracuj¹ ze sob¹ w celu odnalezienia cz¹stki optymalnej. W czasie procesu optymalizacji nastêpuje zmiana po³o¿enia ka¿dej cz¹stki w przestrzeni poszukiwañ poprzez wyznaczenie wektora prêdkoœci. Wektor ten jest modyfikowany przy u¿yciu informacji o historii poszukiwañ danej cz¹stki oraz jej cz¹stek s¹siednich. Metoda PSO w problemie optymalizacji funkcji wielowymiarowych d¹¿y do otrzymania cz¹steczki, która reprezentuje jak najmniejsz¹ wartoœæ funkcji i mo¿e byæ opisana dwoma równaniami \cite{PSOWzory}:

\begin{equation}
v_{t+1}=W*v_t+c_1*r_1*(p-x_t)+c_2*r_2*(g-x_t)
\label{wzor:pso}
\end{equation}
\begin{equation}
x_{t+1}=x_t+v_{t+1}
\end{equation}
gdzie,

$v$ - wektor prêdkoœci cz¹stki

$x$ - pozycja cz¹stki

$W$ – parametr z zakresu $[0,1]$, który determinuje wp³yw poprzedniego po³o¿enia cz¹stki na jej obecn¹ pozycjê

$p$ - najlepsze rozwi¹zanie dla cz¹stki

$g$ – najlepsze rozwi¹zanie dla s¹siedztwa cz¹stek

$r_1,r_2$ – losowe liczby z zakresu $[0,1]$

$c_1,c_2$ – parametry skaluj¹ce z zakresu $[0,1]$
\newline

Nawi¹zuj¹c do powy¿szych równañ, ka¿da cz¹stka roju przeszukuje przestrzeñ rozwi¹zañ zmieniaj¹c po³o¿enie na podstawie swoich najlepszych rozwi¹zañ $p$, jednoczeœnie wykorzystuj¹c informacjê o najlepszym rozwi¹zaniu w s¹siedztwie $g$. Parametry skaluj¹ce umo¿liwiaj¹ kontrolê wp³ywu danych sk³adowych wektora prêdkoœci na wynik. W przypadku, w którym $c_1$ bêdzie równe zero, cz¹stka bêdzie wykorzystywa³a tylko i wy³¹cznie informacjê o najlepszym rozwi¹zaniu w roju. Z kolei jeœli wartoœæ parametru $c_2$ zostanie ustawiona na zero, cz¹stka bêdzie poszukiwa³a rozwi¹zania samodzielnie, bez uwzglêdnienia rozwi¹zañ, które uzyskane zosta³y przez inne cz¹stki. 

\subsubsection{Symulowane wy¿arzanie}

Algorytm symulowanego wy¿arzania po raz pierwszy zosta³ opisany w 1953 roku przez Nicolasa Metropolisa. Sposób dzia³ania algorytmu, jak i równie¿ jego nazwa odnosi siê do procesów fizycznych, które wykorzystywane s¹ w metalurgii. Proces wy¿arzania polega na rozgrzaniu cia³a sta³ego do okreœlonej temperatury, a nastêpnie na jego powolnym studzeniu. Konsekwencj¹ tego dzia³ania jest zmiana struktury krystalicznej materia³u, który poddany zosta³ wy¿arzaniu. W czasie procesu och³adzania metali dostrze¿ono, i¿ cz¹steczki cia³a wraz z jego powolnym sch³adzaniem tworz¹ bardziej regularne struktury, ni¿ w przypadku szybszego obni¿enia temperatury, kiedy to ch³odzone cz¹steczki nie potrafi¹ znaleŸæ optymalnego po³o¿enia.

Algorytm symulowanego wy¿arzania jest usprawnieniem starszych metod iteracyjnych, które polega³y na ci¹g³ym ulepszaniu istniej¹cego rozwi¹zania do momentu braku mo¿liwoœci jego poprawy. W metodach tych zatrzymanie algorytmu mog³o nast¹piæ przy rozwi¹zaniu pseudo-optymalnym – lokalnym minimum. Nie istnia³a wówczas mo¿liwoœæ wyjœcia z owego lokalnego minimum i kierowania siê w kierunku minimum globalnego. Bardzo wa¿n¹ cech¹ opisywanego algorytmu jest mo¿liwoœæ wyboru, z pewnym prawdopodobieñstwem, gorszego rozwi¹zania. 
Dziêki temu problem utkniêcia w lokalnym minimum nie jest ju¿ groŸny. Na wybór gorszego rozwi¹zania ma wp³yw podstawowy parametr przeniesiony z podstaw termodynamicznych algorytmu – temperatura. Im jest ona wy¿sza, tym wiêksze istnieje prawdopodobieñstwo wyboru i zaakceptowania gorszego rozwi¹zania. W czasie dzia³ania algorytmu temperatura obni¿a siê i zachowanie metody zaczyna zbli¿aæ siê w swoim zachowaniu do typowych metod iteracyjnych.
Graficzne przedstawienia schematu pracy algorytmu symulowanego wy¿arzania przedstawione zosta³o na rysunku \ref{rys:sa}. Rysunek ten przez wzgl¹d na lepsz¹ czytelnoœæ przedstawia problem przeciwny do problemu opisywanego w prezentowanej pracy magisterskiej, a wiêc problem poszukiwania globalnego maksimum.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{img_sa.png}
    \caption{Zasada dzia³ania algorytmu symulowanego wy¿arzania w poszukiwaniu maksimum funkcji, 
    Ÿród³o: http://iacs-courses.seas.harvard.edu/
	\newline    
    courses/am207/blog/images/mcmc.png}
    \label{rys:sa}
\end{figure} 

W celu zastosowania algorytmu symulowanego wy¿arzania w kontekœcie optymalizacji funkcji wielu zmiennych nale¿y na pocz¹tku losowo wygenerowaæ punkt startowy, mieœci siê w granicach przestrzeni poszukiwañ, wyliczyæ dla niego wartoœæ funkcji oraz wybraæ temperaturê pocz¹tkow¹. Ka¿da iteracja polega na wyborze losowego rozwi¹zania z s¹siedztwa, wyliczeniu dla niego wartoœci funkcji i porównaniu z obecnie najlepszym rezultatem oraz obni¿eniu temperatury. W przypadku, w którym wartoœæ funkcji nowego punktu jest mniejsza (lepsza), jest on zaklasyfikowany jako najlepszy. W przeciwnej sytuacji punkt nie jest natychmiastowo odrzucany. Algorytm akceptuje gorsze rezultaty bazuj¹c na funkcji akceptacyjnej oraz prawdopodobieñstwie akceptacji, które wyliczane jest na podstawie nastêpuj¹cego wzoru:

\begin{equation}
p_i=\frac{1}{1+exp(\frac{\Delta_i}{T_i})}
\label{wzor:SAprawd}
\end{equation}
gdzie:

$p_i$ - prawdopodobieñstwo akceptacji

$\Delta_i$ – ró¿nica pomiêdzy wartoœci¹ najlepszego punktu oraz punktu w $i$-tej iteracji

$T_i$ – wartoœæ temperatury
\newline

W sytuacji, w której $\Delta_i$ i $T_i$ s¹ wartoœciami dodatnimi, $p_i$ przyjmuje wartoœci z zakresu $(0;\frac{1}{2})$. Ni¿sza temperatura prowadzi do mniejszego prawdopodobieñstwa zaakceptowania gorszego rezultatu. Podobnie jest z $\Delta_i$ – im wiêksza, tym mniejsza szansa na zaakceptowanie.

\subsubsection{Algorytm genetyczny}

Model algorytmu genetycznego po raz pierwszy zaprezentowany zosta³ w 1975 roku przez Johna Hollanda, który w pracy \textit{"Adaptation in Natural and Artificial Systems"} \cite{GetnetycznyPoRazPierwszy} przedstawi³ fundamenty za³o¿eñ dotycz¹cych adaptacji Darwinowskiej teorii ewolucji w systemach informatycznych.  

Opis algorytmu genetycznego bazuje na powszechnej terminologii biologicznej \cite{GenetycznyTerminologia}. Z tego te¿ powodu przyjmuje siê, i¿ algorytmy genetyczne przetwarzaj¹ populacjê osobników, która reprezentuje rozwi¹zanie danego problemu. Ka¿dy element populacji nazywany jest chromosomem, a jego sk³adowe genami. Allele, z kolei, s¹ to mo¿liwe stany (wartoœci) genu, które umiejscowione s¹ na pozycjach zdefiniowanych jako locus. W badanych modelach komputerowych osobniki (chromosomy) mog¹ byæ opisane jako ró¿ne struktury – zaczynaj¹c od ³añcuchów binarnych, a koñcz¹c na bardzo z³o¿onych obiektach. W okreœlonej iteracji zwanej zamiennie pokoleniem albo generacj¹, dane chromosomy na bazie okreœlonej miary ich dostrojenia podlegaj¹ ocenie. Ocena ta skutkuje wyborem najlepiej przystosowanych osobników, które wezm¹ udzia³ w kolejnych iteracjach algorytmu. Nim jednak wybrane osobniki populacji utworz¹ now¹ generacjê, zostaj¹ poddane modyfikacjom bazuj¹cych na podstawowych operacjach genetycznych – krzy¿owaniu, selekcji oraz mutacji.

W kontekœcie problemu optymalizacji funkcji wielu zmiennych, inicjalizacja algorytmu genetycznego polega na wygenerowaniu populacji pocz¹tkowej, która z³o¿ona jest z okreœlonej liczby chromosomów (punktów). Ka¿dy chromosom reprezentowany w populacji posiada tak¹ sam¹ d³ugoœæ, która ustalona jest zale¿nie od rozwi¹zywanego problemu na etapie implementowania algorytmu. Przed rozpoczêciem etapu generowania musi byæ jednak okreœlony sposób kodowania informacji zawartej w chromosomie. W algorytmie Hollanda nie by³o domyœlnie zdefiniowanego sposobu kodowania chromosomów. Powszechnie uznaje siê jednak stosowanie kodowania binarnego \cite{GenetycznyKodowanieBinarne}. Takie te¿ kodowanie jest zastosowane w kontekœcie omawianego problemu optymalizowania funkcji wielu zmiennych. Kolejnym etapem, który nastêpuje po wygenerowaniu populacji pocz¹tkowej oraz wyborze kodowania chromosomów, jest wyznaczenie jakoœci chromosomów danej populacji. W tym celu obliczana jest wartoœæ tak zwanej funkcji oceny, która definiuje poziom dopasowania konkretnego chromosomu. W zagadnieniach dotycz¹cych optymalizacji, funkcj¹ t¹ jest zwykle optymalizowana funkcja, nazywana funkcj¹ celu. Tym sposobem mo¿na stwierdziæ, które z nich lepiej rozwi¹zuj¹ dane zagadnienie, a które gorzej. Znalezienie rozwi¹zania danego problemu sprowadza siê do znalezienia ekstremum (minimum) wspomnianej funkcji oceny. Kolejn¹ czêœci¹ algorytmu jest zastosowanie mechanizmu selekcji, który definiuje sposób wyboru rozwi¹zañ rodzicielskich, z których tworzone bêd¹ tak zwane rozwi¹zania potomne u¿yte w nastêpnej generacji. Prostym w implementacji operatorem selekcji dla algorytmu genetycznego jest metoda ruletki \cite{GenetycznyRuletka}. Metoda ta polega na przydzieleniu ka¿demu chromosomowi z danej populacji prawdopodobieñstwa wed³ug wzoru:

\begin{equation}
p_i = \frac{f_i}{\sum_{j=1}^{N}f_j}
\end{equation}

gdzie:

$f_i$ - wartoœæ funkcji oceny \textit{i}-tego chromosomu 

$p_i$ – prawdopodobieñstwo reprodukcji \textit{i}-tego chromosomu 

$N$ - liczba chromosomów w populacji
\newline

W celu wybrania puli rodzicielskiej, ko³o ruletki o obwodzie jeden dzielone jest na czêœci o d³ugoœci $p_i$, a nastêpnie z zakresu $[0,1]$ losowana jest,  zgodnie z rozk³adem jednostajnym liczba, która jednoznacznie identyfikuje punkt na ruletce, a co za tym idzie konkretny chromosom. Chromosom ten brany bêdzie pod uwagê w procesie nastêpnej reprodukcji, a losowanie powtarzane jest tak d³ugo, a¿ wylosowana zostanie ustalona liczba chromosomów. W problemie minimalizacji funkcji wielu zmiennych istnieje mo¿liwoœæ, i¿ wartoœæ funkcji oceny bêdzie ujemna. W celu zniwelowania problemu ujemnego prawdopodobieñstwa powy¿szy wzór zosta³ zmodyfikowany stosuj¹c skalowanie przystosowania:

\begin{equation}
p_i = \frac{f_i-f_{min}}{\sum_{j=1}^{N}f_j-f_{min}}
\end{equation} 

gdzie $f_{min}$ jest wartoœci¹ funkcji przystosowania najgorszego chromosomu. \newline

Po etapie selekcji pozostaje do zdefiniowania kwestia wymiany pokoleñ. W implementacjach czêsto stosowana jest metoda ca³kowitego zastêpowania, w której ca³a aktualna populacja podlega operacjom krzy¿owania i mutacji. Innym sposobem jest metoda zastêpowania czêœciowego, w której czêœæ najlepszych chromosomów obecnej populacji przechodzi do populacji potomnej bez ¿adnych zmian, a pozosta³e elementy z kolei bior¹ udzia³ w operacji krzy¿owania i mutacji. Kolejn¹ popularn¹ praktyk¹ jest zastosowanie zastêpowania elitarnego, w którym na podstawie parametru okreœlaj¹cego wielkoœæ elity, czêœæ najlepszych osobników jest kopiowana do nowej generacji ju¿ na samym pocz¹tku. Umo¿liwia to zapamiêtanie najlepszych chromosomów, które mog¹ byæ zmienione w wyniku dzia³ania operatorów genetycznych rozpoczynaj¹cych swoj¹ pracê po zakoñczeniu etapu selekcji.

Pierwszym z takich operatorów jest krzy¿owanie, które jest operacj¹ umo¿liwiaj¹c¹ tworzenie nowych rozwi¹zañ. Jego koncept bazuje na procesie rozmna¿ania organizmów, w czasie trwania którego potomek dziedziczy czêœæ genów rodziców. W kontekœcie omawianego algorytmu genetycznego, krzy¿owanie polega na przeciêciu chromosomów w ustalonym punkcie i ich wzajemnego zamienienia. Operacja ta zosta³a przedstawiona na rysunku \ref{rys:gen_krzyz}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{img_krzyz.png}
    \caption{Graficzna prezentacja operacji krzy¿owania jednopunktowego, Ÿród³o: https://www.linkedin.com/pulse/genetic-algorithms-sharmishtha-mahajan-patwardhan}
    \label{rys:gen_krzyz}
\end{figure} 

Drugim operatorem genetycznym jest mutacja, która umo¿liwia wprowadzenie nowego elementu do populacji poprzez tworzenie ró¿norodnoœci. Analogicznie jak w otaczaj¹cym nas œwiecie, w algorytmie genetycznym mutacje zdarzaj¹ siê rzadko. Ich skala zale¿y od parametru, który przyjmuje zazwyczaj niskie wartoœci. W odniesieniu do chromosomów w postaci binarnej, mutacja mo¿e polegaæ na zamianie losowego genu na wartoœæ przeciwn¹. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{img_muta.png}
    \caption{Graficzna prezentacja operacji mutacji, 
    \newline    
    Ÿród³o: http://web.arch.usyd.edu.au/
    \newline
    \textasciitilde rob/applets/house/images/single\_point\_mutation.png}
    \label{rys:gen_muta}
\end{figure} 

Tak utworzona nowa generacja ponownie przechodzi przez wszystkie punkty algorytmu. Dzieje siê tak a¿ do czasu, w którym spe³nione zostan¹ warunki zatrzymania, które w kontekœcie przedstawianego zagadnienia opisane zosta³y w podpunkcie \ref{dzial:MetodyPorownawczeWybranychAlgorytmow} opisuj¹cym metody porównawcze wybranych algorytmów obejmuj¹ce równie¿ warunki stopu opisanych trzech metaheurystyk.

\section{Za³o¿enia projektu}
\label{dzial:ZalozeniaProjektu}

Porównanie algorytmów metaheurystycznych w odniesieniu do problemu minimalizacji funkcji wielu zmiennych jest zadaniem bardzo skomplikowanym przez fakt liczby doœwiadczeñ, które nale¿y wykonaæ. Badania porównawcze przeprowadzane bêd¹ pod k¹tem kilku parametrów. Dla ka¿dego z nich wymagane bêdzie przeprowadzenie wielokrotnych testów dla ka¿dego testowanego algorytmu i funkcji testowej. 
W celu przeanalizowania mo¿liwoœci œrodowiska obliczeniowego Matlab, przeprowadzone zosta³y próby "rêcznego" uruchamiania eksperymentów numerycznych. Przeprowadzenie owych testów okaza³o siê bardzo czasoch³onnym zadaniem i ukaza³o ograniczon¹ funkcjonalnoœæ œrodowiska w kontekœcie agregowania wyników. Wyniki analizy wymusi³y koniecznoœæ rozwa¿enia sposobu automatyzacji zaplanowanych testów umo¿liwiaj¹cych porównanie algorytmów metaheurystycznych. Przemyœlenia poskutkowa³y powstaniem, zaprezentowanej na rysunku \ref{rys:flow}, ogólnej architektury umo¿liwiaj¹cej zautomatyzowanie czasoch³onnego procesu oraz trwa³e przechowywanie otrzymanych rezultatów w miejscu umo¿liwiaj¹cym ich efektywn¹ agregacjê.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img_flow.png}
    \caption{Ogólna architektura umo¿liwiaj¹ca zautomatyzowanie przeprowadzania eksperymentów numerycznych, Ÿród³o: Opracowanie w³asne.}
    \label{rys:flow}
\end{figure}

Architektura ta sprowadza siê do zbudowania dedykowanej aplikacji bazodanowej, która umo¿liwiaæ bêdzie automatyzacjê przeprowadzanych testów. U¿ytkownik z poziomu aplikacji bêdzie mia³ mo¿liwoœæ wyboru funkcji testowej, algorytmu metaheurystycznego oraz jego parametrów, a tak¿e liczby testów, która ma byæ przeprowadzona przy zadanych wartoœciach. Aplikacja automatycznie bêdzie wysy³aæ zapytania do œrodowiska obliczeniowego Matlab, odbieraæ wyniki testów oraz umieszczaæ je w bazie danych, za poœrednictwem której w prosty i efektywny sposób mo¿na bêdzie przeprowadziæ ich agregacjê w celu przedstawienia wyników i ich podsumowania. W ten sposób narzut pracy, który niezbêdny jest do implementacji przedstawionej aplikacji, zwróci siê oraz umo¿liwi dalsz¹ analizê algorytmów w kontekœcie problemu optymalizacji funkcji wielu zmiennych, poniewa¿ aplikacja umo¿liwiaæ bêdzie równie¿ proste dodanie do niej kolejnych algorytmów oraz funkcji testowych.

\section{Wykorzystane rozwi¹zania technologiczne}
\label{dzial:WykorzystaneRozwiazaniaTechnologiczne}

\subsection{Zastosowane technologie}
\label{dzial:ZastosowaneTechnologie}

Obecny rozdzia³ obejmuje opis wykorzystanych technologii, które umo¿liwi³y implementacjê aplikacji. Opis ten dotyczy jêzyka programowania, w którym napisana zosta³a warstwa logiki aplikacji oraz silnika graficznego programu wraz z jêzykiem zapytañ bazy danych.

\subsubsection{.NET Framework/C\#}

.NET Framework jest to platforma programistyczna wydana przez firmê Microsoft w 2002 roku. Przeznaczona jest ona do wytwarzania oprogramowania przeznaczonego dla systemów operacyjnych z rodziny Windows. G³ówn¹ sk³adow¹ przedstawianej platformy s¹ kompilatory jêzyków wysokiego poziomu, które umo¿liwiaj¹ przeprowadzenie operacji kompilacji programów napisanych w jêzykach Visual Basic, F\#, C++/CLI. Platforma .NET wspiera równie¿ jeden z najpopularniejszych jêzyków programowania na œwiecie - C\#, w którym napisana zosta³a aplikacja odnosz¹ca siê do prezentowanej pracy magisterskiej. C\# jest to nowoczesny, zorientowany obiektowo jêzyk programowania stworzony przez firmê Microsoft. Jego pierwsza wersja wydana zosta³a ju¿ w po³owie 2000 roku, przy du¿ej zas³udze g³ównego projektanta jêzyka - duñskiego in¿yniera oprogramowania Andersa Hejlsberga \cite{Hejlsberg}. Jêzyk ten mo¿e zostaæ u¿yty w celu pisania aplikacji webowych, desktopowych oraz przeznaczonych na urz¹dzenia przenoœne. Programy w nim napisane kompilowane s¹ do poœredniego kodu, który zapisany jest w CIL (ang. Common Intermediate Language) i wykonany w œrodowisku uruchomieniowym .NET Framework. Poziom trudnoœci nauki C\# uznawany jest za stosunkowo niski, g³ównie z powodu posiadania licznych udogodnieñ oraz modu³ów, które upraszczaj¹ pracê programistyczn¹ \cite{CSharpAdvantages}. Do elementów tych mo¿na zaliczyæ brak koniecznoœci dodawania plików nag³ówkowych, które niezbêdne by³y w jêzyku C++, automatyczne zwalnianie dynamicznie przydzielonej pamiêci, za które odpowiedzialny jest Garbage Collector, inicjalizowanie zmiennych ich domyœlnymi wartoœciami oraz wprowadzenie dodatkowych elementów sk³adowych klas, takich jak indeksery oraz w³aœciwoœci (ang. \textit{properties}).

\subsubsection{WPF / XAML}
\label{dzial:WpfXaml}
Windows Presentation Foundation (WPF) \cite{WPF} jest to silnik graficzny, który wprowadzony zosta³ wraz z trzeci¹ wersj¹ œrodowiska .NET. Okna w aplikacjach zaimplementowanych w WPF wyœwietlane s¹ za pomoc¹ grafiki wektorowej, która wspomagana jest przez akceleratory grafiki 3D. API warstwy prezentacji, w technologii WPF opiera siê na jêzyku XML \cite{Xml}, a konkretniej jego odmianie - XAML. Extensible Application Markup Language (XAML) jest to deklaratywny jêzyk znaczników, którego przeznaczeniem jest opis interfejsu u¿ytkownika implementowanego w WPF. Pozwala on zaprojektowanie oraz rozmieszczenie wszelakich elementów wizualnych, a tak¿e umo¿liwia zrównoleglenie pracy programistów pracuj¹cych nad logik¹ biznesow¹ budowanej aplikacji oraz grafików, którzy odpowiedzialni s¹ za tworzenie graficznego interfejsu u¿ytkownika. Zdarza siê, i¿ graficy przez wzgl¹d na zakres swoich obowi¹zków nie znaj¹ ¿adnego jêzyka programowania. Problem ten zosta³ zniwelowany dziêki jêzykowi XAML, który pozwala na zrozumienie przez osoby nietechniczne zasady dzia³ania oraz powi¹zañ poszczególnych okien. Umo¿liwia on tak¿e projektowanie graficznego interfejsu u¿ytkownika w prosty sposób z poziomu drzewiastej struktury lub dedykowanego programu graficznego Expression Blend, który umo¿liwia przeprowadzenie wszelkich operacji z poziomu graficznego œrodowiska.

\subsubsection{TSQL}

Transaction-SQL (T-SQL) \cite{T-SQL} jest rozwiniêcie standardowego jêzyka SQL, który to utworzony zosta³ w latach siedemdziesi¹tych na potrzeby relacyjnych baz danych przez firmê IBM. T-SQL pozwala na tworzenie konstrukcji takich jak instrukcje warunkowe i pêtle oraz umo¿liwia stosowanie zmiennych. Aktualnie stosowany on jest do tworzenia zapytañ bazodanowych przez firmy, które potrzebuj¹ bardziej zaawansowanych struktur ni¿ te, które dostêpne s¹ w standardowym SQL. T-SQL wprowadzi³ mo¿liwoœæ stosowania bazodanowych wyzwalaczy, procedur oraz funkcji sk³adowanych, które przy rozbudowanej strukturze tabel u³atwiaj¹ pracê przy bazie danych.

\subsection{Zastosowane narzêdzia}

W celu efektywnej pracy z technologiami, które opisane zosta³y w podpunkcie \ref{dzial:ZastosowaneTechnologie} warto u¿yæ dedykowanych narzêdzi, które u³atwiaj¹ zastosowanie funkcjonalnoœci wspomnianych technologii. W tym celu w trakcie pracy nad prezentowanym projektem magisterskim u¿ytych zosta³o kilka narzêdzi, które pozwoli³y skróciæ czas potrzebny na implementacjê aplikacji, przeprowadzenie badañ oraz zagregowanie ich rezultatów.

\subsubsection{Matlab}

Matlab jest to œrodowisko przeznaczone do wykonywania obliczeñ numerycznych, matematycznych oraz symulacyjnych. Nazwa œrodowiska odnosi siê do s³ów MATrix LABoratory, gdy¿ Matlab przeznaczony by³ pocz¹tkowo do numerycznych obliczeñ macierzowych. Aktualnie aplikacja ta ma zdecydowanie wiêksze mo¿liwoœci - posiada liczne funkcje biblioteczne, umo¿liwia ich rozbudowê, a tak¿e definiowanie nowych przez u¿ytkownika. Matlab posiada równie¿ dedykowany jêzyk programowania, czego konsekwencj¹ jest mo¿liwoœæ pisania w pe³ni funkcjonalnych aplikacji pracuj¹cych w opisywanym œrodowisku.
W aspekcie grafiki, Matlab pozwala na rysowanie dwu- oraz trójwymiarowych wykresów, a tak¿e wizualizacjê rezultatu obliczeñ w postaci animacji. Istotn¹ kwesti¹ w kontekœcie prezentowanej pracy magisterskiej jest posiadanie przez œrodowisko Matlab terminala, który pozwala na wprowadzanie komend i wykonywanie funkcji. Istnieje mo¿liwoœæ jego samodzielnego uruchomienia oraz po³¹czenia z innymi systemami za poœrednictwem dedykowanych bibliotek, które umo¿liwiaj¹ synchronizacjê Matlaba z aplikacjami napisanymi w technologii .NET, Java czy C++.

\subsubsection{SQL Server Management Studio 17}

W czasie pracy nad aplikacj¹ automatyzuj¹c¹ proces przeprowadzania testów wykorzystano darmowe narzêdzie, którego przeznaczeniem jest zarz¹dzanie baz¹ danych - SQL Server Management Studio 17. Potrzeba u¿ycia narzêdzia, którego interfejs u¿ytkownika zaprezentowany zosta³ na rysunku \ref{rys:manaStudio}, wynik³a z istniej¹cej infrastruktury aplikacji, która opiera siê na rozwi¹zaniach Microsoftu. Zastosowane narzêdzie znacznie u³atwi³o pracê i wspomog³o proces projektowania bazy danych dziêki funkcjonalnoœci generowania diagramów, które umo¿liwi³y podgl¹d struktury bazy oraz relacji pomiêdzy poszczególnymi tabelami. Kolejn¹ zalet¹ SQL Management Studio jest mo¿liwoœæ tworzenia zapytañ bazodanowych, które pozwalaj¹ w bardzo elastyczny sposób pogrupowaæ olbrzymie iloœci danych w wybrany przez u¿ytkownika sposób. Umo¿liwia to w krótkim czasie stworzenie statystyk dla badanych algorytmów, które dynamicznie bêd¹ siê aktualizowa³y wraz z nap³ywem kolejnych danych do bazy.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img_managementStudio.png}
    \caption{Interfejs SQL Server Management Studio 2017
    Ÿród³o: Opracowanie w³asne.}
    \label{rys:manaStudio}
\end{figure} 

\subsubsection{Visual Studio 2015}

Visual Studio \cite{bookVS} jest to bardzo rozbudowane œrodowisko deweloperskie firmy Microsoft. Stosowane jest do procesu wytwarzania oprogramowania z graficznym interfejsem u¿ytkownika w technologii WPF, WinForms, Web Sites oraz Xamarin. Visual Studio posiada zaawansowany edytor kodu, który wspiera mechanizm podpowiadania sk³adni kodu - IntelliSense, który mo¿e byæ dodatkowo rozbudowany poprzez dedykowane narzêdzia, np. Resharper. Zintegrowany debugger zawarty w œrodowisku Visual Studio umo¿liwia równie¿ analizê programu w czasie jego dzia³ania, dziêki czemu mo¿liwe jest odnalezienie w bardzo ³atwy sposób potencjalnych b³êdów oraz sprawdzenie poprawnoœci zaimplementowanego rozwi¹zania. Funkcje te, wraz z wbudowanymi narzêdziami do projektowania baz danych oraz tworzenia aplikacji w technologii WPF, umo¿liwi³y przeprowadzenie implementacji budowanego systemu stosuj¹c jedno œrodowisko, dziêki czemu mo¿liwa by³a du¿a oszczêdnoœæ czasowa w zakresie poszukiwañ niezbêdnych narzêdzi i ich integracji. Visual Studio, SQL Server Management Studio 17 oraz zastosowane technologie s¹ wytwarzane przez jedn¹ firmê - Microsoft. Dziêki temu aspektowi ich po³¹czenie i synchronizacja jest bezproblemowa i bardzo szybka.

\subsubsection{Resharper}

Wydajnoœæ pracy w komercyjnych projektach programistycznych jest priorytetem, który bezpoœrednio przek³ada siê na oszczêdnoœæ czasow¹, a co za tym idzie, na korzyœci finansowe. Dostêpne s¹ narzêdzia, których przeznaczeniem jest u³atwienie pracy osobie implementuj¹cej aplikacjê poprzez kontrolê pisanego przez niego kodu wed³ug zdefiniowanych uprzednio zasad oraz zautomatyzowanie czêsto powtarzanych czynnoœci. Resharper jest to dodatek do œrodowiska Visual Studio, który w znacznym stopniu rozbudowuje dostêpne jego funkcjonalnoœci, u³atwiaj¹c przy tym refaktoryzacjê oraz pisanie kodu. 
Funkcje, które mog¹ byæ zastosowane z poziomu Resharpera, mo¿na podzieliæ na kilkanaœcie grup, z których jedn¹ z najwa¿niejszych jest modu³, który zajmuje siê inspekcj¹ kodu. W trakcie pisania kodu z uruchomionym w tle Resharperem nastêpuje sprawdzanie w czasie rzeczywistym ponad 2000 zasad, które dotycz¹ jego poprawnoœci i w sytuacji znalezienia niespójnoœci, nastêpuje poinformowanie programisty na poziomie interfejsu Visual Studio o zaistnia³ym b³êdzie wraz z jego szczegó³owym opisem i miejscem wyst¹pienia. Niespójnoœci te mog¹ dotyczyæ dla przyk³adu mo¿liwoœci zast¹pienia czêœci kodu jego wydajniejsz¹ wersj¹, ostrze¿eniem programisty przed fragmentem kodu, który potencjalnie mo¿e spowodowaæ b³êdne dzia³anie ca³ej aplikacji oraz fragmentami "martwego" kodu.
Kolejn¹ bardzo wa¿n¹ funkcjonalnoœci¹ jest generowanie kodu. W czasie pracy implementacyjnej sporo czynnoœci takich jak edycja nazw czy pisanie nowych klas oraz metod notorycznie siê powtarza. Za pomoc¹ skrótów klawiaturowych, wszystkie powy¿sze akcje Resharper wykona za programistê. Wygeneruje on niezbêdne przy dziedziczeniu interfejsu wszystkie jego sk³adowe, przeniesie dan¹ klasê do odrêbnego pliku oraz automatycznie dokona zamiany wybranej nazwy na inn¹ w obrêbie ca³ej solucji. 
Zaprezentowane funkcje Resharpera wraz z innymi, które opisane zosta³y w artykule \cite{ResharperFeatures}, umo¿liwi³y zmniejszenie czasu potrzebnego na implementacjê niezbêdnych w projekcie modu³ów poprzez zminimalizowanie liczby pojawiaj¹cych siê zagro¿eñ we wczesnej fazie pisania kodu oraz zautomatyzowanie powtarzalnych czynnoœci.  

\subsection{Wykorzystane biblioteki zewnêtrzne}

W trakcie budowy systemu informatycznego zdarzaj¹ siê sytuacje, w których konieczne jest korzystanie z aplikacji ró¿nych firm, które domyœlnie nie umo¿liwiaj¹ ich po³¹czenia. Problem taki wyst¹pi³ równie¿ w czasie pracy nad prezentowanym projektem magisterskim. U¿ycie narzêdzia innego producenta ni¿ Microsoft, jakim jest Matlab, doprowadzi³o do koniecznoœci znalezienia metody jego po³¹czenia ze œrodowiskiem .NET.

\subsubsection{Matlab Application Type Library v.1.0}
\label{dzial:MatlabApplicationLibrary}

Matlab Application Type Library w wersji pierwszej jest to otwarta biblioteka przeznaczona dla œrodowiska .NET posiadaj¹ca API umo¿liwiaj¹ce wykonywanie operacji Matlabowych stosuj¹c sk³adniê C\#. Biblioteka ta umo¿liwia odwo³ywanie siê do uprzednio zdefiniowanych w Matlabie funkcji, dostarczaj¹c odpowiednich parametrów oraz odbiera wyniki obliczeñ, które mog¹ byæ dalej przetwarzane bez koniecznoœci ich manualnego kopiowania. Biblioteka posiada bardzo ogólnie zdefiniowane metody, do których prawid³owego wykonania wymagana jest dok³adna wiedza, która jednak ograniczona jest przez wzgl¹d na brak dokumentacji. Przy d³u¿szej pracy jest jednak mo¿liwe dojœcie do sposobu skorzystania na poziomie C\# z zaawansowanych funkcji, które dostarcza œrodowisko Matlab. W podpunkcie \ref{dzial:KomunikacjaMatlabaZProjektem} przedstawiono dok³adny sposób przekazywania i odbierania danych pomiêdzy œrodowiskiem .NET oraz Matlabem.

\section{Architektura budowanej aplikacji}
\label{dzial:ArchitekturaBudowanejApl}

Budowa bazodanowej aplikacji komunikuj¹cej siê z systemem trzecim (Matlab) wymaga szczegó³owej analizy wszystkich elementów, które maj¹ odniesienie do jej architektury. Przez koniecznoœæ budowy dwóch oddzielnych elementów - bazy danych oraz aplikacji desktopowej - analiza ta podzielona zosta³a na czêœæ odwo³uj¹c¹ siê do architektury aplikacji, modelowania bazy danych oraz jej komunikacji z projektem programistycznym oraz komunikacji œrodowiska Matlab z implementowan¹ aplikacj¹. Powi¹zanie miêdzy elementami oraz przep³yw informacji w tworzonym systemie zaprezentowany zosta³ na rysunku \ref{rys:model}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img_model.png}
    \caption{Powi¹zania pomiêdzy elementami budowanego systemu, Ÿród³o: Opracowanie w³asne.}
    \label{rys:model}
\end{figure} 


\subsection{Architektura aplikacji}

W aspekcie programowania, podobnie jak w innych dziedzinach, w których przeprowadzana jest operacja budowy zadanego elementu, nale¿y dok³adnie zaplanowaæ jego proces. W aktualnym rozdziale przedstawiony zosta³ opis sposobu, który pozwoli³ na uporz¹dkowanie procesu budowania aplikacji oraz opis jego modyfikacji dostosowanej do technologii WPF, która zastosowana zosta³a podczas pracy nad prezentowan¹ prac¹ magistersk¹. W podpunkcie \ref{dzial:ModelAplikacji} zosta³ równie¿ zawarty szczegó³owy opis poszczególnych elementów projektu programistycznego, który jest efektem pracy implementacyjnej.
 
\subsubsection{Wzorce architektoniczne oprogramowania}

Bardzo dobr¹ praktyk¹ programistyczn¹ jest przeprowadzenie procesu budowy aplikacji w taki sposób, aby mo¿liwy by³ efektywny jej rozwój oraz dokonanie w ³atwy sposób zmian w istniej¹cych ju¿ funkcjonalnoœciach. W tym celu budowê aplikacji nale¿y przeprowadzaæ zgodnie z ustalonymi etapami produkcji oprogramowania \cite{FazyProdukcjiOpr}. Etapy te definiuj¹ obowi¹zek ustalenia wymagañ budowanego systemu oraz okreœlenia jego ogólnej architektury. Czêœæ dotycz¹ca okreœlenia architektury jest bardzo wa¿na, poniewa¿ jej zmiana podczas fazy implementacji jest niebywale problematyczna do wykonania i w wielu przypadkach wrêcz niemo¿liwa bez koniecznoœci powtórnego rozpoczêcia pracy od pocz¹tku. Kolejne etapy maj¹ na celu zrealizowanie zdefiniowanej wczeœniej architektury poprzez zaprogramowanie ka¿dego komponentu wraz z ich wszystkimi wzajemnymi po³¹czeniami, przetestowanie ca³oœci zaimplementowanego systemu, a tak¿e jego uruchomienie oraz zniwelowanie b³êdów, które pojawi³y siê w trakcie jego dzia³ania.
W kontekœcie planowania i budowania architektury systemu bardzo u¿yteczne s¹ wzorce architektoniczne, które s¹ powszechnymi, sprawdzonymi oraz ogólnie przyjêtymi sposobami rozwi¹zania okreœlonego problemu z zakresu architektury oprogramowania. Definiuj¹ one ogóln¹ strukturê systemu informatycznego, elementy, które wchodz¹ w jego sk³ad, oraz zasadê komunikowania siê komponentów pomiêdzy sob¹. Dokonanie wyboru odpowiedniego wzorca jest w du¿ym stopniu zale¿ne od technologii, która stosowana jest w projekcie. W przypadku prezentowanej aplikacji oraz technologii WPF, na której ona bazuje, stosowanym powszechnie wzorcem jest \textit{Model View ViewModel (MVVM)} \cite{MvvmOpis}, który jest odmian¹ ogólnego wzorca MVC.

\subsubsection{Zastosowany wzorzec architektoniczny – MVVM}

MVVM jest to wzorzec, który dziêki separacji warstwy logiki biznesowej oraz warstwy prezentacji pozwala na tworzenie ³atwo testowalnej aplikacji, której fragmenty kodu mog¹ byæ ponownie u¿yte w innych projektach programistycznych. Aplikacje implementowane w technologii WPF przy u¿yciu wzorca MVVM umo¿liwia równie¿ ich prost¹ rozbudowê, a poprzez obowi¹zek zachowania odpowiedniej struktury kodu, zrozumienie kodu przez now¹ osobê jest o wiele prostsze i mniej czasoch³onne ni¿ w przypadków aplikacji pisanych bez ¿adnej ogólnie zachowanej struktury. MVVM jest to wzorzec, który jest bardzo popularny w gronie programistów skoncentrowanych przy technologii WPF. Powodem tego jest mo¿liwoœæ u¿ycia najwiêkszych zalet tej technologii, takich jak \textit{binding} \cite{WpfBinding} (wi¹zania), \textit{behavior} (zachowania) oraz \textit{command} \cite{WpfCommands} (komendy). Struktura kodu aplikacji bazuj¹cej na opisywanym wzorcu podzielona jest na trzy oddzielne warstwy, których nazwy sk³adaj¹ siê na nazwê wzorca: Model, Widok (View) oraz Model Widoku (ViewModel). Ka¿da z warstw spe³nia w aplikacji specjalnie okreœlone funkcje i przetwarza dedykowane dla siebie dane. Graficzna prezentacja oraz kierunki przesy³ania danych zaprezentowano na rysunku \ref{rys:mvvm}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{img_mvvm.png}
    \caption{Przep³yw danych we wzorcu MVVM, Ÿród³o: https://i-msdn.sec.s-msft.com/dynimg/IC648329.png}
    \label{rys:mvvm}
\end{figure} 

Warstwa Modelu we wzorcu MVVM odpowiedzialna jest za tak zwan¹ logikê biznesow¹ budowanego systemu. W aplikacji implementowanej na potrzeby prezentowanej pracy magisterskiej, warstwa ta zawiera wszystkie klasy, które stworzone zosta³y za pomoc¹ narzêdzia mapowania obiektowo-relacyjnego Entity Framework w celu odwzorowania relacyjnej bazy danych na poziom obiektów dostêpnych w kodzie.
Ka¿da klasa zawarta w czêœci modelu, której dane maj¹ zostaæ wys³ane do warstwy widoku w celu ich wyœwietlenia u¿ytkownikowi, zobligowana jest do implementacji interfejsu \textit{INotifyPropertyChanged}, który aktywnie wspó³pracuje z wi¹zaniem stosowanym w WPF.
Drug¹ z kolei warstw¹ jest warstwa widoku, której funkcja sprowadza siê wy³¹cznie do wyœwietlania danych i realizowana jest poprzez prezentowanie danych w oknie aplikacji, do którego dostêp maj¹ u¿ytkownicy systemu.
Ostatni¹ warstw¹ modelu MVVM jest warstwa ViewModel, której przeznaczeniem jest poœredniczenie w wymianie danych pomiêdzy modelem oraz widokiem, do którego nie posiada jednak ¿adnej referencji. Elementy widoku odnosz¹ siê do ViewModel dziêki wspomnianym ju¿ komendom oraz wi¹zaniom. Taki mechanizm zapewnia w pe³ni separacjê warstwy ViewModel, a co za tym idzie, umo¿liwia pe³ne jego przetestowanie bez ¿adnej zale¿noœci od rzeczywistej warstwy widoku oraz modelu.

\subsubsection{Model aplikacji}
\label{dzial:ModelAplikacji}

U¿ycie wzorca MVVM w aplikacji implementowanej na potrzeby prezentowanej pracy magisterskiej doprowadzi³o do powstania obszernej solucji, na któr¹ sk³ada siê ponad siedemdziesi¹t plików. Dziêki zaplanowanej strukturze podzia³u elementów na foldery, zachowano porz¹dek, który umo¿liwia szybkie oraz intuicyjne wyszukiwanie potrzebnych sk³adowych aplikacji. Wszelkie pliki klas zosta³y umiejscowione w katalogach nazwanych w sposób adekwatny do ich przeznaczenia, przez co odnalezienie przez programistê szukanego elementu nie przysparza ¿adnych problemów.

\subsubsection*{Managers}

\textit{Managers} jest to katalog zawieraj¹cy klasê menad¿era tworz¹cego i wysy³aj¹cego ¿¹danie przeprowadzenia doœwiadczenia do œrodowiska Matlab. Menad¿er ten za poœrednictwem klas dopasowuj¹cych tworzy ¿¹danie zgodne ze standardem zastosowanej biblioteki opisanej w \ref{dzial:MatlabApplicationLibrary}, wysy³a je do œrodowiska obliczeniowego oraz odbiera rezultaty.

\subsubsection*{Matlab}

Folder \textit{Matlab} ukazany na rysunku \ref{img:KatalogMatlab} zawiera pliki funkcji zapisanych w œrodowisku Matlab. Pliki te zawieraj¹ definicje trzech algorytmów metaheurystycznych oraz wybranych funkcji testowych. Przez fakt na ograniczon¹ funkcjonalnoœæ zastosowanego API, ³¹cz¹cego œrodowisko .NET ze œrodowiskiem Matlab, definicje funkcji testowych oraz algorytmów musia³y znaleŸæ siê w jednym katalogu z powodu braku wsparcia dotycz¹cego przejœcia pomiêdzy ró¿nymi katalogami.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{img_KatalogMatlab.png}
    \caption{Widok na pliki funkcji napisanych w œrodowisku Matlab z poziomu solucji, Ÿród³o: Opracowanie w³asne.}
    \label{img:KatalogMatlab}
\end{figure} 

\subsubsection*{Model}

Katalog Modelu przedstawiony na rysunku \ref{img:KatalogModel} zawiera utworzon¹ przez Entity Framework strukturê obiektow¹ relacyjnej bazy danych. Liczba plików, które zawiera uzale¿niona jest bezpoœrednio od liczby tabel, która zastosowana zosta³a w bazie danych. W czasie dzia³añ implementacyjnych nie jest konieczna wiedza o dok³adnej strukturze przedstawianego folderu. Wystarczaj¹ce s¹ informacje dotycz¹ce tego, która bazodanowa tabela zawiera jakie dane.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{img_KatalogModel.png}
    \caption{Widok na pliki wygenerowane przez Entity Framework z poziomu solucji, Ÿród³o: Opracowanie w³asne.}
    \label{img:KatalogModel}
\end{figure} 

\subsubsection*{Services}

Katalog \textit{Servies} zawiera dwa serwisy stosowane w prezentowanej aplikacji. Pierwszym z nich jest serwis bazy danych który umo¿liwia po³¹czenie siê z fizycznie istniej¹c¹ baz¹ danych. Za pomoc¹ dedykowanych obiektów Entity Framework umo¿liwia on zapisywanie do bazy danych rezultatów przeprowadzonych doœwiadczeñ oraz pobieranie niezbêdnych danych dotycz¹cych stosowanych algorytmów oraz funkcji testowych.
Drugim z kolei serwisem jest serwis Matlaba, który przechowuje obiekty umo¿liwiaj¹ce dwukierunkow¹ komunikacjê ze œrodowiskiem obliczeniowym.

\subsubsection*{Tools}

Katalog narzêdzi jest najbardziej rozbudowanym katalogiem w drzewie solucji. Przez wzgl¹d na jego szerokie zastosowanie posiada on trzy podfoldery, które uœciœlaj¹ definicjê elementów w nich siê znajduj¹cych. Pierwszym z nich jest \textit{Parser}, który zawiera t³umacza rezultatów otrzymanych ze œrodowiska obliczeniowego. Przez wzgl¹d na nieuporz¹dkowan¹ formê danych otrzymywanych z Matlaba pojawi³a siê koniecznoœæ ich uporz¹dkowania. W listingu \ref{listing:ParseResultsFromMatlab} zawarty zosta³ kod metody umo¿liwiaj¹cej przeprowadzenie tej operacji. Drugi podkatalog zawarty w sekcji \textit{Tools} to \textit{Utils}, w którym umiejscowione s¹ dwie bardzo wa¿ne metody dopasowuj¹ce nazwy Matlabowych plików na podstawie wybranego algorytmu metaheurystycznego oraz funkcji testowej. Ostatnim podkatalogiem jest \textit{MatlabContextWrapper}, który posiada metody u³atwiaj¹ce odwo³ywanie siê do obiektów komunikacyjnych, które poœrednicz¹ w dwukierunkowym przekazywaniu informacji pomiêdzy œrodowiskami .NET oraz Matlab.

\begin{lstlisting}[caption= {Implementacja oraz opis funkcji t³umacz¹cej informacje odebrane ze œrodowiska obliczeniowego Matlab.}, label={listing:ParseResultsFromMatlab}]
public ResultDetail ParseResult(object[] result)
{
// tworzenie obiektu zawieraj¹cego szczegó³y otrzymanego rezultatu
  var resultDetails = new ResultDetail
  {
    BestFunctionValue = Convert.ToDecimal(result[1]),
    Iterations = Convert.ToInt32(result[2]),
    FunctionEvaluations = Convert.ToInt32(result[3]),
    TotalTime = Convert.ToDecimal(result[4]),
  };

// wyci¹ganie wspó³rzêdnych punktu wraz z numerem wymiaru przestrzeni której dotycz¹
  var resultPointLoc = result[0] as double[,];
  for (var i = 0; i < resultPointLoc.Length; i++)
  {
    resultDetails.Point.Add(new Point
    {
      PointValue = resultPointLoc[0,i],
      ResultDimension = i + 1,
    });
  }
  return resultDetails;
}
\end{lstlisting}


\subsubsection*{View}

Katalog widoku jest katalogiem najwa¿niejszym ze strony u¿ytkownika poniewa¿ zawiera definicjê budowy g³ównego okna aplikacji oraz umiejscowienia wszystkich kontrolek jakie ono zawiera. W tym w³aœnie miejscu wykorzystywany jest opisany w podpunkcie \ref{dzial:WpfXaml} jêzyk XAML, który pozwala na przeprowadzenie operacji wi¹zañ oraz stosowanie komend.

\subsubsection*{ViewModel}

Ostatni opisywany katalog - \textit{ViewModel} - zawiera pliki dostosowane do pracy ze wzorcem MVVM. Odpowiadaj¹ one na interakcjê u¿ytkownika oraz realizuj¹ akcje dostêpne z poziomu okna aplikacji, w którym pracuje u¿ytkownik. Wa¿nym elementem ze strony programistycznej jest plik \textit{ViewModelLocator}, w którym przeprowadzana jest operacja rejestrowania wszelkich typów zastosowanych w aplikacji. Dziêki temu, mo¿liwe jest skorzystanie ze wzorca wstrzykiwania zale¿noœci \cite{DependencyInjection}, który pozwala na pisanie kodu o luŸniejszych powi¹zaniach, prostszego w testowaniu oraz modyfikacji.

\subsection{Architektura bazy danych}

Analiza tematu projektu dotycz¹ca porównania algorytmów metaheurystycznych doprowadzi³a do powstania potrzeby zastosowania œrodowiska bazodanowego, które umo¿liwi³oby przechowywanie oraz agregowanie wyników przeprowadzonych doœwiadczeñ. W prezentowanym rozdziale opisany zosta³ serwer bazodanowy przechowuj¹cy instancjê bazy wraz z metod¹ jego dzia³ania oraz model utworzonej bazy danych.

\subsubsection{Microsoft SQL Server – system do zarz¹dzania baz¹ danych}

Zastosowanie w projekcie bazy danych wymusi³o obowi¹zek utworzenia oraz uruchomienia serwera bazodanowego. Przez fakt na zastosowane technologie, których opis znajduje siê w podpunkcie \ref{dzial:ZastosowaneTechnologie}, u¿yty zosta³ Microsoft SQL Server. Jest to relacyjny system zarz¹dzania baz¹ danych, którego podstawow¹ funkcj¹ jest przechowywanie danych oraz ich przetwarzanie na ¿¹danie innych aplikacji, które mog¹ dzia³aæ na tym samym komputerze lub na innej maszynie w sieci LAN czy te¿ WAN. Przydatnym narzêdziem przy pracy z Microsoft SQL Serverem jest dedykowane narzêdzie z graficznym interfejsem u¿ytkownika, które w znacznym stopniu upraszcza korzystanie z jego funkcji.
W przypadku budowanej aplikacji serwer bazodanowy zosta³ utworzony na maszynie lokalnej, na której dzia³a równie¿ aplikacja automatyzuj¹ca testy. Na potrzeby przeprowadzanych doœwiadczeñ rozwi¹zanie to jest wystarczaj¹ce przez fakt braku koniecznoœci posiadania bardzo szybkiego œrodowiska, które wymaga uiszczenia op³at adekwatnych do rodzaju wykupywanego serwera.

\subsubsection{Budowa bazy danych u¿ytej w projekcie}

Przed rozpoczêciem etapu implementacyjnego oraz po zakoñczeniu analizy dotycz¹cej wyboru wzorca architektonicznego aplikacji, zaprojektowana zosta³a struktura tabel bazodanowych wraz ze ich wszystkimi dostêpnymi kolumnami oraz typami, a tak¿e po³¹czenia i relacje miêdzy nimi. Proces projektowania bazy danych jest procesem bardzo wa¿nym, a jednoczeœnie czêsto bagatelizowanym. W sytuacji nieprzemyœlanego zaprojektowania bazy danych istnieje mo¿liwoœæ pojawienia siê problemu z jej rozbudow¹ i dodawaniem kolejnych potrzebnych tabel, na których mia³yby operowaæ nowe funkcjonalnoœci aplikacji. Nieprzemyœlana struktura tabel mo¿e doprowadziæ do zbêdnego powielania danych, której konsekwencj¹ bêdzie bardzo szybko powiêkszaj¹cy siê rozmiar bazy danych. Kolejnym efektem Ÿle zaprojektowanej bazy mo¿e byæ spowolniona praca i d³ugie wykonywanie zapytañ. W celu unikniêcia przedstawionych problemów, dokonana zosta³a szczegó³owa analiza wymaganych funkcjonalnoœci oraz danych, które one zwracaj¹. Wykorzystana w budowanej aplikacji baza danych mo¿e zostaæ podzielona na dwa g³ówne sk³adniki - czêœæ s³ownikow¹ zawieraj¹c¹ opisy wybranych algorytmów metaheurystycznych oraz funkcji testowych, a tak¿e czêœæ dotycz¹c¹ przeprowadzanych badañ oraz wyników przez nie otrzymanych.

\subsubsection*{Czêœæ s³ownikowa}

Na s³ownikow¹ czêœæ bazy danych sk³adaj¹ siê trzy tabele przedstawione na rysunku \ref{rys:baza_slownik}, które zawieraj¹ dane wejœciowe niezbêdne w aplikacji: \textit{Alghoritms}, \textit{TestFunctions} oraz \textit{ExitFlags}.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img_bazaSlownik.png}
    \caption{Przestawienie czêœci s³ownikowej bazy danych, Ÿród³o: Opracowanie w³asne.}
    \label{rys:baza_slownik}
\end{figure} 

Tabela \textit{Alghoritms} jest prost¹ tabel¹ s³ownikow¹ zawieraj¹c¹ identyfikator oraz nazwê algorytmu metaheurystycznego. Lista algorytmów dostêpnych do przetestowania w aplikacji znajduje siê w³aœnie w tej tabeli. Na podstawie nazwy algorytmu, dopasowywana jest jej funkcja Matlabowa, w której tkwi g³ówna logika algorytmu. W celu prawid³owego obs³u¿enia kolejnego algorytmu, nale¿y dodaæ wpis w opisywanej tabeli oraz wed³ug odpowiedniego schematu umiejscowionego w klasie \textit{FunctionNameMatcher} stworzyæ funkcjê w aplikacji Matlab. Tak utworzony schemat algorytmu nale¿y kolejno dodaæ do warstwy ViewModel oraz dostosowaæ logikê okna u¿ytkownika do wymaganych przez algorytm parametrów. 

\textit{TestFunctions} jest to tabela, która zawiera opis funkcji testowych na bazie których dokonywane s¹ testy algorytmów. Zawarte w niej s¹ takie informacje jak identyfikator funkcji, jej nazwa, poziom trudnoœci ustalony na bazie stopnia skomplikowania funkcji testowej zaczerpniêty z \cite{RankingFunkcjiTestowych}, odnoœnik do wykresu danej funkcji wraz z informacjami na jej temat, zakres p³aszczyzny w obrêbie której ma byæ poszukiwana wartoœæ minimalna oraz wymiar funkcji czyli liczba zmiennych, na której owa funkcja bazuje. W celu dodania do aplikacji kolejnej funkcji testowej nale¿y dokonaæ dodania jej definicji w opisywanej tabeli oraz utworzyæ plik Matlabowy zawieraj¹cy jej wzór. Nazwa pliku powinna zgadzaæ siê ze schematem zawartym w klasie dopasowuj¹cej - \textit{FunctionNameMatcher}. Tak utworzona funkcja bêdzie automatycznie dostêpna do wyboru z poziomu aplikacji.

Ostatnia tabela z czêœci s³ownikowej bazy danych to tabela \textit{ExitFlags}, w której zdefiniowane s¹ numery flag wyjœcia z Matlabowych funkcji oraz ich opis. Przeznaczeniem jej jest uzyskanie informacji dotycz¹cej powodu zakoñczenia pracy danego algorytmu. Powodem tym mo¿e byæ dla przyk³adu osi¹gniêcie maksymalnego za³o¿onego czasu dzia³ania algorytmu, liczby iteracji lub liczby odwo³añ do funkcji testowej.

\subsubsection*{Czêœæ dotycz¹ca przeprowadzonych badañ}

Czêœæ bazy danych odnosz¹ca siê do przeprowadzanych badañ jest czêœci¹ bardziej rozbudowan¹ ni¿ czêœæ s³ownikowa. Zawiera ona wszelkie informacje dotycz¹ce parametrów wejœciowych danego testu oraz rezultaty przeprowadzanych badañ. G³ówn¹ tabel¹, która jest swojego rodzaju trzonem bazy danych jest tabela \textit{Results}. Po przeprowadzeniu pojedynczego doœwiadczenia w tabeli tej tworzony jest wpis, który zawiera identyfikatory wierszy odnosz¹ce siê do wszystkich niezbêdnych tabel, które umo¿liwiaj¹ uzyskanie wszelkich informacji o doœwiadczeniu.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img_bazaDane.png}
    \caption{Przestawienie czêœci bazy danych dotycz¹cej przeprowadzanych badañ, Ÿród³o: Opracowanie w³asne.}
    \label{rys:baza_dane}
\end{figure} 

W tabeli \textit{InputParameters} zawarte s¹ informacje o parametrach wejœciowych algorytmów takich jak zadany maksymalny czas dzia³ania algorytmu, maksymalna liczba iteracji, dopuszczalna liczba odwo³añ do funkcji testowej oraz w zale¿noœci od wybranego algorytmu wielkoœæ roju lub wielkoœæ populacji.

Rezultaty przeprowadzonego badania umiejscawiane s¹ w tabeli \textit{ResultDetails}, w której to mo¿na uzyskaæ informacjê na temat liczby przeprowadzonych iteracji, liczby odwo³añ do funkcji testowej, najmniejszej znalezionej wartoœci funkcji, czasu dzia³ania algorytmu oraz informacjê o powodzeniu jego wykonania. Dodatkowym elementem, który przechowywany jest w bazie jest lokalizacja punktu posiadaj¹cego najmniejsz¹ znalezion¹ wartoœæ funkcji. Pocz¹tkowo temat pracy magisterskiej zak³ada³ porównanie algorytmów metaheurystycznych bazuj¹c wy³¹cznie na funkcjach dwóch zmiennych. Lokalizacja najlepszego punktu przechowywana by³a w dwóch kolumnach tabeli \textit{ResultDetails}. Po zmianie wymagañ, które dotyczy³y koniecznoœci obs³u¿enia funkcji wielu zmiennych, musia³a nast¹piæ modyfikacja struktury bazy danych. Warte wspomnienia s¹ tutaj fazy dok³adnej analizy potrzeb, które baza danych ma spe³niaæ oraz proces jej projektowania. Ju¿ na tym etapie jako jedno z ryzyk projektowych za³o¿one zosta³o zmienienie podejœcia do liczby wymiarów funkcji testowych. W celu zapewnienia prawid³owego przetwarzania i przechowywania danych zosta³a w tym celu stworzona nowa tabela - \textit{Points}. Tabela ta jest w relacji wiele do jednego z tabel¹ \textit{ResultDetails} oraz umo¿liwia przechowywanie wspó³rzêdnej punktu dla ka¿dego wymiaru jako oddzielny wpis. Dla przyk³adu, lokalizacja punktu dla funkcji piêciu zmiennych przechowywana bêdzie w postaci piêciu wpisów w omawianej tabeli, z których ka¿dy opisywaæ bêdzie jego lokalizacjê oraz numer wymiaru do którego ma odniesienie.

\subsection{Komunikacja bazy danych z projektem programistycznym}

Umo¿liwienie kontaktu aplikacji z baz¹ dan¹ jest kluczow¹ kwesti¹, która odnosi siê do prawid³owego dzia³ania bazodanowego projektu programistycznego. Bezpieczne, stabilne oraz ci¹g³e po³¹czenie umo¿liwia pozbawione problemów przesy³anie danych z gwarancj¹ ich niezmiennoœci oraz odpowiedni¹ informacj¹ w momencie pojawienia siê b³êdu komunikacyjnego. W technologii .NET, w której implementowana jest aplikacja bazodanowa mo¿liwe jest kilka podejœæ do omawianego zagadnienia. Jednym z nich jest standardowe podejœcie udostêpniane przez ADO.NET oraz nowsze, które dotyczy komunikacji na poziomie obiektów.

\subsubsection{Mapowanie obiektowo-relacyjne}

Mapowanie obiektowo-relacyjne (ang. ORM - Object-Relational Mapping) jest to pojêcie, które dotyczy informatycznego terminu odnosz¹cego siê do wspó³pracy z baz¹ danych przy wykorzystaniu programowania obiektowego. Dok³adniej chodzi tutaj o translacjê danych, które przechowywane s¹ w tabelach bazodanowych w relacyjnej bazie danych na postaæ obiektow¹, która dostêpna jest z poziomu projektu programistycznego. Przedstawiony sposób komunikacji jest sposobem bardzo u¿ytecznym przez wzgl¹d na brak koniecznoœci analizy struktury bazy danych przez programistê oraz umo¿liwienie pobierania oraz zapisu danych z poziomu kodu, unikaj¹c bazodanowego jêzyka zapytañ SQL.
Aplikacje komputerowe, które u¿ywane s¹ przez wielu u¿ytkowników oraz wymagaj¹ pobierania i zapisywania du¿ych iloœci danych czêsto korzystaj¹ z serwerów bazodanowych. Serwery te pozwalaj¹ na przechowywanie danych bez ¿adnych przerw oraz ich szybkie wyszukiwanie, dodawanie oraz edycjê. Aspekt ten jest bardzo trudny do osi¹gniêcia korzystaj¹c wy³¹cznie ze standardowych aplikacji. W technologii .NET standardowa komunikacja z baz¹ danych przebiega za pomoc¹ protoko³u ADO.NET. Przy jego zastosowaniu, w celu pobrania danych, programista musi za ka¿dym razem po³¹czyæ siê z baz¹ danych, manualnie napisaæ zapytanie SQL, odebraæ wynik, zapisaæ go w zmiennej oraz zamkn¹æ po³¹czenie. Schemat ten bardzo komplikuje kwestiê utrzymania aplikacji w sytuacji modyfikacji struktury bazy danych. Zapisane przez programistê zapytanie SQL nie podlega procesowi walidacji pod k¹tem poprawnoœci jego formy, a w sytuacji edycji kolumny bazodanowej, nastêpuje obowi¹zek uaktualnienia wszystkich zapytañ, które jej dotyczy³y. Przyk³adowy schemat pracy podczas korzystania z ADO.NET wraz z porównaniem analogicznej operacji w technologii ORM zaprezentowane zosta³o na poziomie kodu Ÿród³owego \ref{listing:PorownanieAdoEf}.

\begin{lstlisting}[caption={Porównanie operacji dodania algorytmu heurystycznego do tabeli \textit{Alghoritms} w ADO.NET oraz Entity Framework.}, label={listing:PorownanieAdoEf}]

//ADO.NET
// ADO.NET wymaga manualnego dodania pliku konfiguracyjnego zawieraj¹cego œcie¿kê z ustawieniami po³¹czenia do bazy danych.
SqlConnection connection = 
    new SqlConnection(connectionString);
SqlCommand command = 
    new SqlCommand(@"INSERT INTO [TestDb].[Alghoritms]  
    VALUES (@Name)", connection);           
command.Parameters.Add(
    new SqlParameter("NazwaAlgorytmu"));
connection.Open();
command.ExecuteNonQuery();
connection.Close();

//Entity Framework
// Entity Framework automatycznie odczyta wygenerowany przez bibliotekê plik konfiguracyjny.
MyDataContext dataContext = new MyDataContext();
Alghoritm newAlghoritm = new Alghoritm
{ Name = "Harmony Search" };
dataContext.Alghoritms.Add(newAlghoritm);
dataContext.SaveChanges(); 
\end{lstlisting}

W implementowanej aplikacji bazodanowej, zdecydowano siê przeciwdzia³aæ opisanym problemom, stosuj¹c framework, który w znacznym stopniu u³atwia programiœcie zastosowanie wszystkich operacji dotycz¹cych komunikacji z baz¹ danych.

\subsubsection{Zastosowane narzêdzie mapowania obiektowo relacyjnego – Entity Framework}

Entity Framework jest to dedykowane dla platformy .NET narzêdzie mapowania obiektowo-relacyjnego, którego zadaniem jest wspieranie budowy trójwarstwowych aplikacji bazodanowych. Budowa obiektowego modelu bazy danych w opisywanym narzêdziu mo¿e byæ wykonana na trzy sposoby.

Pierwsz¹ metod¹ jest \textit{Code First}, który pozwala na utworzenie fizycznego modelu bazy danych na podstawie klas napisanych w jêzyku C\# oraz ich odpowiednimi przypisami \cite{PrzypisyCodeFirst}.

Kolejnym sposobem jest podejœcie \textit{Database First}, które jest u¿yteczne w sytuacji, w której dostêpna jest dzia³aj¹ca ju¿ baza danych. Korzystaj¹c z dostêpnego w frameworku kreatora, istnieje mo¿liwoœæ okreœlenia lokalizacji bazy oraz poddania jej automatycznemu mapowaniu, w wyniku którego wygenerowane zostaj¹ niezbêdne klasy obiektowego modelu bazy danych.

Ostatni¹ metod¹ jest \textit{Model First}, które polega na utworzeniu fizycznego modelu bazy danych pos³uguj¹c siê wbudowanemu w Entity Framework Designerem, który w du¿ym stopniu upraszcza tworzenie w³aœciwoœci oraz encji bazodanowych. Œcie¿ka ta stosowana jest, gdy posiadany jest wy³¹cznie sam schemat bazy danych. Ze zbudowanego modelu nastêpuje wygenerowanie fizycznego modelu bazy danych jak i równie¿ klas, które reprezentuj¹ model obiektowy. Sposób ten zosta³ zastosowany w prezentowanej pracy magisterskiej. Po analizie wymagañ i utworzeniu schematu bazy danych, zosta³ on przeniesiony na poziom Designera opisywanego frameworku, który automatycznie stworzy³ skrypt napisany w jêzyku SQL, po wykonaniu którego utworzony zosta³ fizyczny model bazy danych, a tak¿e wygenerowane zosta³y wszystkie niezbêdne klasy reprezentuj¹ce model obiektowy zadanego schematu bazy.

\subsection{Komunikacja Matlaba z projektem programistycznym}
\label{dzial:KomunikacjaMatlabaZProjektem}

Poprawne skomunikowanie aplikacji bazodanowej ze œrodowiskiem obliczeniowym Matlab by³o najtrudniejsz¹ czêœci¹ podczas ca³ej pracy implementacyjnej. Podczas tworzenia architektury budowanej aplikacji poszukiwany by³ efektywny sposób integracji obu œrodowisk. Przez fakt utworzenia ich przez ró¿nych producentów, nie istnieje domyœlnie wbudowana funkcjonalnoœæ ich integracji. Poszukiwania doprowadzi³y do zastosowania dedykowanej dla œrodowiska .NET biblioteki opisanej w podpunkcie \ref{dzial:MatlabApplicationLibrary}, która ³¹czy siê z poœrednicz¹cym serwerem Matlaba. Serwer ten nie jest domyœlnie dodawany przy instalacji œrodowiska obliczeniowego, dlatego te¿ nachodzi koniecznoœæ jego dodatkowego doinstalowania. Biblioteka umo¿liwia stworzenie ¿¹dania na poziomie C\#, które nastêpnie przekazywane jest do serwera poœrednicz¹cego, które t³umaczy je na jêzyk stosowany przez Matlaba. ¯¹danie te jest  wykonywane przez œrodowisko obliczeniowe, a jego rezultat analogiczn¹ œcie¿k¹ przekazywany jest do aplikacji bazodanowej. Sporym problemem okaza³o siê prawid³owe tworzenie ¿¹dañ przez fakt na bardzo ograniczon¹ dokumentacjê biblioteki i ma³¹ liczbê przyk³adów. Na podstawie metody prób i b³êdów uda³o siê jednak utworzyæ prawid³owy typ ¿¹dañ oraz w sposób w³aœciwy dokonywaæ odbioru ich odpowiedzi. ¯¹danie w kodzie Ÿród³owym numer \ref{listing:SendRequestToMatlab} prezentuje sposób wykonania pojedynczego doœwiadczenia dotycz¹cego algorytmu symulowanego wy¿arzania, natomiast kod Ÿród³owy numer \ref{listing:ParseResultsFromMatlab}, który umiejscowiony zosta³ ju¿ w punkcie \ref{dzial:ModelAplikacji}, ukazuje sposób przetwarzania otrzymanej odpowiedzi.

\begin{lstlisting}[caption= {Implementacja oraz opis funkcji wysy³aj¹cej ¿¹danie do œrodowiska obliczeniowego Matlab.}, label={listing:SendRequestToMatlab}]
private ResultDetail ExecuteSimulatedAnnealingAlghoritm( Alghoritm alghoritm, TestFunction testFunction, InputParameter inputParameter)
{
// pobranie nazwy pliku, w którym znajduje siê logika przetwarzanego algorytmu
 var alghoritmFileName = FunctionNameMatcher.GetAlghoritmFileName(alghoritm);
// pobranie nazwy pliku, w którym znajduje siê wzór przetwarzanej funkcji
 var testFunctionFileName = FunctionNameMatcher.GetFunctionFileName(testFunction);

// czyszczenie obiektu przechowuj¹cego otrzymany rezultat 
 _computedResult = null;

// wywo³anie ¿¹dania 
 _matlabContext.Feval(
  alghoritmFileName,
  5, // OutputParamsNumber
  out _computedResult,
  (double)inputParameter.MaxTime,
  (double)inputParameter.MaxIterations,
  (double)inputParameter.MaxFunctionEvaluations,
  (double)inputParameter.MaxStallIterations,
  testFunctionFileName,
  (double)testFunction.BoundRange,
  testFunction.Dimension
  );

// zwrócenie odpowiednio przetworzonego rezultatu
 return _resultParser.ParseResult(_computedResult as object[]);
}
\end{lstlisting}

\subsection{Uruchomienie aplikacji bazodanowej}

W celu uruchomienia zaimplementowanej aplikacji bazodanowej niezbêdne jest posiadanie œrodowiska obliczeniowego Matlab R2017 w wersji 9.2, serwera SQL wraz z narzêdziem SQL Server Management Studio 17 oraz .NET Framework w wersji 4.5.1.
Przed uruchomieniem aplikacji, niezbêdn¹ operacj¹ jest odpowiednia konfiguracja serwera bazodanowego. W tym celu, w narzêdziu SQL Server Management Studio nale¿y utworzyæ bazê danych za pomoc¹ skryptu \textit{EntityDataModel.edmx.sql} za³¹czonego do solucji programistycznej. Po jego wykonaniu utworzone zostan¹ wszystkie niezbêdne tabele bazodanowe wraz z odpowiednimi relacjami. Kolejnym krokiem jest dodanie wymaganych danych do czêœci s³ownikowej bazy danych. Odpowiedzialny jest za to skrypt \textit{AddDictionaries.sql}, po wykonaniu którego dodane zostan¹ wszelkie niezbêdne informacje dotycz¹ce porównywanych algorytmów heurystycznych oraz u¿ytych funkcji testowych. Tak przygotowane œrodowisko, na bazie domyœlnej konfiguracji umo¿liwia uruchomienie zaimplementowanej aplikacji, która podczas startu uruchamia automatycznie aplikacjê Matlab. Niweluje to koniecznoœæ pamiêtania o uruchomieniu œrodowiska obliczeniowego manualnie. Okno uruchomionej aplikacji, które aktualnie wykonuje testy, widoczne jest na rysunku \ref{rys:apka}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{img_apka.png}
    \caption{Widok na oko g³ówne aplikacji podczas przeprowadzania testów, Ÿród³o: Opracowanie w³asne.}
    \label{rys:apka}
\end{figure} 

\section{Badania eksperymentalne}

Ca³y proces pocz¹wszy od pomys³u automatyzacji przeprowadzanych badañ zawarty w punkcie \ref{dzial:ZalozeniaProjektu}, przez analizê rozwi¹zañ technologicznych opisanych w punkcie \ref{dzial:WykorzystaneRozwiazaniaTechnologiczne}, po budowê architektury oraz samej aplikacji bazodanowej ujêty w punkcie \ref{dzial:ArchitekturaBudowanejApl} mia³ za zadanie u³atwiæ przeprowadzenie eksperymentalnych badañ porównawczych wybranych algorytmów metaheurystycznych. W obecnym rozdziale przedstawiony zosta³ opis metod porównawczych, a tak¿e samych badañ doœwiadczalnych wraz z ich zagregowanymi wynikami zawartymi w podpunkcie \ref{dzial:WynikiDoswiadczenDlaZadanychFun}.

\subsection{Metody porównawcze wybranych algorytmów}
\label{dzial:MetodyPorownawczeWybranychAlgorytmow}

W celu zrównania szans ka¿dego z porównywanych algorytmów, wszystkie przeprowadzane testy dokonane zosta³y na tej samej maszynie obliczeniowej o parametrach przedstawionych na rysunku \ref{rys:specyfikacja} przy tych samych warunkach obci¹¿eniowych systemu. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{img_specyfikacja.png}
    \caption{Przestawienie parametrów komputera na którym przeprowadzane by³y testy, Ÿród³o: Opracowanie w³asne.}
    \label{rys:specyfikacja}
\end{figure} 

Bazuj¹c na informacjach zawartych w artykule \cite{MetodyPorownawczeDoc} dokonano wyboru dwóch kryteriów pod k¹tem których przeprowadzane zosta³y testy porównawcze algorytmów.
Pierwszym z kryteriów porównawczym by³ maksymalny czas, w którym algorytm poszukiwa³ najlepszego rezultatu. Parametr ten bra³ pod uwagê kilka ró¿nych ustalonych wartoœci dla których przeprowadzana zosta³a próbka doœwiadczeñ, z których wartoœci œrednie zosta³y zestawione i porównane w obrêbie wszystkich algorytmów oraz funkcji testowych. Drugim kryterium porównawczym by³a liczba odwo³añ algorytmu do zadanej funkcji testowej. W kryterium tym porównane zosta³y, w sposób analogiczny jak w kryterium pierwszym, rezultaty otrzymane przez algorytmy przy takim za³o¿eniu, i¿ mog³y one wyliczyæ wartoœæ funkcji testowej okreœlon¹ liczbê razy.

\subsection{Opis przeprowadzonych badañ}

\subsubsection{Skalowanie algorytmów}

Przez wzgl¹d na du¿¹ liczbê parametrów ka¿dego porównywanego algorytmu heurystycznego, zdecydowano siê dokonaæ ich dostrojenia przed przeprowadzeniem zaplanowanych badañ. Na bazie wybranych funkcji testowych wykonano liczne testy, na bazie których wybrano parametry, dla których œrednia uzyskanych rezultatów by³a najlepsza. Dla algorytmu symulowanego wy¿arzania jako metoda sch³adzaj¹ca, wybrana zosta³a standardowa funkcja
\begin{equation}
NowaTemperatura = ObecnaTemperatura * 0.95^k
\end{equation}
, gdzie \textit{k} jest numerem iteracji od wy¿arzenia. Uwzglêdniaj¹c fakt du¿ej liczby iteracji, któr¹ algorytm móg³ wykonaæ podczas testów, zdecydowano siê wprowadziæ mo¿liwoœæ wyst¹pienia operacji ponownego wy¿arzenia (ang. reannealing), w czasie której algorytm ponownie ustala temperaturê na domyœln¹ wartoœæ $100$ stopni i kontynuuje pracê. Wartoœæ parametru dotycz¹cego mo¿liwoœci wyst¹pienia ponownego wy¿arzania ustalona zosta³a na poziomie $40$ i definiuje liczbê punktów, które algorytm ma obowi¹zek zaakceptowaæ przed wyst¹pieniem wspomnianej operacji.
W metodzie optymalizacji rojem cz¹stek domyœlne parametry wzoru \ref{wzor:pso} zawartego w podpunkcie \ref{dzial:MetodaOptymalizacjiRojemCzastek} ustalone zosta³y na nastêpuj¹ce wartoœci:
$W = 0.6$, $c_1 = c_2 = 0.75$.
Algorytm genetyczny z kolei wymaga³ najwiêkszej iloœci testów skaluj¹cych przez fakt posiadania najwiêkszej liczby mo¿liwych kombinacji parametrów. Na ich postawie wybrano metodê ruletki jako metodê selekcji, zastêpowanie elitarne o wielkoœci elity równej $0.05*WielkoscPopulacji$ jako metodê wymiany pokoleñ oraz metodê krzy¿owania jednopunktowego.

\subsubsection{Przeprowadzenie doœwiadczeñ w zaimplementowanym œrodowisku testowym}

W zaimplementowanej aplikacji, dla ka¿dego opisanego w podpunkcie \ref{dzial:MetodyPorownawczeWybranychAlgorytmow} kryterium, umieszczane by³y ustalone wartoœci parametrów, po czym przeprowadzana by³a operacja uruchomienia programu. Dla kryterium maksymalnego czasu, w którym algorytmy poszukiwa³y globalnego minimum funkcji, doœwiadczenia wykonywane zosta³y dla zakresu od jednej do piêciu sekund, z jednosekundowym interwa³em. Liczba testów dla ka¿dej wartoœci z ustalonego zakresu ustalona zosta³a na poziomie stu prób. Pozosta³e parametry, takie jak maksymalna liczba iteracji oraz odwo³añ do funkcji wraz z maksymaln¹ liczb¹ iteracji bez poprawy wyniku, ustalone zosta³y na niemo¿liw¹ do osi¹gniêcia wartoœæ $999999$. Spowodowane by³o to tym, i¿ jednym warunkiem stopu w przedstawianej metodzie porównawczej by³ maksymalny ustalony czas dzia³ania algorytmu.
W przypadku algorytmu genetycznego oraz optymalizacji rojem cz¹stek dodatkowo przeprowadzone zosta³y doœwiadczenia dla ró¿nych wielkoœci populacji i roju, dziêki czemu mo¿liwa do wykonania by³a analiza wp³ywu tych parametrów na otrzymane rezultaty.

Przeprowadzenie badañ dotycz¹cych kryterium maksymalnej liczby odwo³añ do funkcji testowej przebiega³o w sposób analogiczny, z t¹ ró¿nic¹, i¿ niemo¿liw¹ do osi¹gniêcia wartoœci¹ $999999$ zosta³ objêty maksymalny czas poszukiwañ, który w opisywanym kryterium nie by³ brany pod uwagê. Wartoœæ parametru dotycz¹cego maksymalnej liczby odwo³añ do funkcji testowej ustalona zosta³a na poziomie $1000, 2000, 3000, 4000, 5000$ oraz $6000$.

\subsection{Wyniki doœwiadczeñ dla zadanych funkcji testowych}
\label{dzial:WynikiDoswiadczenDlaZadanychFun}

Aktualny rozdzia³ prezentuje zagregowane wyniki przeprowadzanych doœwiadczeñ dla funkcji testowych opisanych w podpunkcie \ref{dzial:FunkcjeTestowe}. Prezentacja wyników dla ka¿dej funkcji testowej podzielona zosta³a na dwie czêœci przez wzgl¹d na dwa kryteria porównawcze algorytmów zdefiniowane w podpunkcie \ref{dzial:MetodyPorownawczeWybranychAlgorytmow}. Warte zdefiniowania jest znaczenie kolorów tabel zawartych w poni¿szych podrozdzia³ach. Zielony kolor definiuje najlepsze otrzymane rezultaty w obrêbie jednego testu, czerwony natomiast wyniki gorsze.

\subsubsection{Funkcja Bohachevsky’ego I}

W tabeli \ref{tab:boh_ga_1} przedstawione zosta³y wyniki otrzymane przez algorytm genetyczny dla kryterium czasowego. Wynika z niej, i¿ najlepsze rezultaty uzyskane zosta³y dla wielkoœci populacji równej $100$.
Dla metody optymalizacji rojem cz¹stek otrzymane rezultaty zaprezentowane zosta³y w tabeli \ref{tab:boh_pso_1}, z której wynika, i¿ najlepsze wyniki uzyskane zosta³y dla wielkoœci roju równej 50 oraz 100. W tym jednak przypadku, jako najlepsze rezultaty wybrane zosta³y wyniki z wielkoœci¹ roju równ¹ 100, z powodu mniejszej liczby odwo³añ do funkcji testowej ni¿ w przypadku roju o wielkoœci 50.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{boh_ga_1.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Bohachevsky’ego I - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:boh_ga_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{boh_pso_1.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Bohachevsky’ego I - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:boh_pso_1}
\end{table}

Najlepsze rezultaty algorytmu genetycznego oraz optymalizacji rojem cz¹stek zosta³y zestawione wraz z rezultatami symulowanego wy¿arzania w tabeli \ref{tab:boh_all_1}. Wynika z niej, i¿ najlepsze wyniki dla ka¿dej wartoœci parametru maksymalnego czasu uzyska³a metoda optymalizacji rojem cz¹stek, która w ka¿dym przypadku znalaz³a minimum globalne dla funkcji Bohachevsky'ego I, którego wartoœæ wynosi 0. Na drugim miejscu uplasowa³ siê algorytm genetyczny, którego wyniki oscylowa³y wokó³ minimum globalnego, jednak w ani jednym przypadku go nie osi¹gnê³y. Algorytm symulowanego wy¿arzania uzyska³ lepszy rezultat od algorytmu genetycznego tylko w przypadku testu dotycz¹cego maksymalnego czasu dzia³ania algorytmu równego jedn¹ sekundê. W pozosta³ych przypadkach uzyska³ najgorsze rezultaty ze wszystkich porównywanych algorytmów metaheurystycznych.


\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{boh_all_1.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Bohachevsky’ego I - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:boh_all_1}
\end{table}

W przypadku kryterium dotycz¹cym okreœlonej maksymalnej liczby odwo³añ algorytmu do funkcji testowej, otrzymane rezultaty s¹ bardzo zbli¿one do rezultatów poprzedniego kryterium. Algorytm genetyczny najlepsze wyniki uzyska³ dla wielkoœci populacji równej 100, co mo¿na zaobserwowaæ na wykresie \ref{tab:boh_ga_2}. Metoda optymalizacji rojem cz¹stek, wed³ug wykresu \ref{tab:boh_pso_2}, najlepsze rezultaty zanotowa³a dla wielkoœci roju równego 50, co jest inn¹ wartoœci¹ ni¿ w przypadku kryterium czasowego. Wyniki te zosta³y zestawione w tabeli \ref{tab:boh_all_2} z rezultatami otrzymanymi przez algorytm symulowanego wy¿arzania, z której wynika i¿ ponownie dla ka¿dej wartoœci zadanego kryterium, najlepsza okaza³a siê metoda optymalizacji rojem cz¹stek.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{boh_ga_2.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Bohachevsky’ego I - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:boh_ga_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{boh_pso_2.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Bohachevsky’ego I - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:boh_pso_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{boh_all_2.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Bohachevsky’ego I - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:boh_all_2}
\end{table}

\subsubsection{Funkcja Colville'a}

Dla funkcji Colville'a, wyniki testów sprawdzaj¹cych optymaln¹ wielkoœæ populacji dla algorytu genetycznego przedstawione zosta³y w tabeli \ref{tab:col_ga_1}, z której wynika, i¿ najbli¿ej minimum globalnego dla kryterium czasowego uplasowa³y siê rezultaty z wielkoœci¹ populacji równ¹ 100. Taka sama wartoœæ zosta³a ustalona dla analogicznego testu sprawdzaj¹cego optymaln¹ wielkoœæ roju dla metody optymalizacji rojem cz¹stek widocznego na wykresie \ref{tab:col_pso_1}. Wyniki obu testów zosta³y zestawione z rezultatami otrzymanymi przez algorytm symulowanego wy¿arzania na wykresie \ref{tab:col_all_1}. Z wykresu tego wynika, i¿ najbli¿ej wartoœci 0, która jest minimum globalnym badanej funkcji, uplasowa³y siê rezultaty otrzymane przez metodê optymalizacji rojem cz¹stek. Wyniki zwrócone przez algorytm genetyczny umiejscowi³y go na drugim miejscu, przed algorytmem symulowanego wy¿arzania, którego rezultaty by³y bardzo odleg³e od poszukiwanego minimum globalnego.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{col_ga_1.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Colville'a - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:col_ga_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{col_pso_1.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Colville'a - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:col_pso_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[height=0.75\textwidth]{col_all_1.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Colville'a - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:col_all_1}
\end{table}

Rezultaty dotycz¹ce testów dla kryterium odnosz¹cego siê do maksymalnej liczby odwo³añ algorytmu do funkcji testowej okaza³y siê bardzo ciekawe przez wzgl¹d na uzyskanie najlepszych rezultatów przez inny algorytm ni¿ w kryterium poprzednim. Do podsumowuj¹cego testu wszystkich trzech algorytmów metaheurystycznych zosta³y wybrane dla algorytmu genetycznego rezultaty przedstawione w tabeli \ref{tab:col_ga_2} z wielkoœci¹ populacji równ¹ 100, natomiast dla metody optymalizacji rojem cz¹stek wyniki z wielkoœci¹ roju równ¹ 10, które dostêpne s¹ do wgl¹du w tabli \ref{tab:col_pso_2}. Podsumowanie widoczne w tabeli \ref{tab:col_all_2} pozwala dostrzec, i¿ najlepsze wyniki uzyska³ algorytm genetyczny, który w testach pierwszego kryterium uzyska³ drugi rezultat.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{col_ga_2.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Colville'a - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne., Ÿród³o: Opracowanie w³asne.}
    \label{tab:col_ga_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{col_pso_2.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Colville'a - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:col_pso_2}
\end{table}

Porównuj¹c wyniki dla obu kryteriów porównawczych z tabel \ref{tab:col_all_1} oraz \ref{tab:col_all_2}, widoczna jest zale¿noœæ wyjaœniaj¹ca taki efekt. Metoda optymalizacji rojem cz¹stek przeprowadza³a znacznie wiêcej odwo³añ do badanej funkcji Colville'a ni¿ algorytm genetyczny dla tego samego czasu pracy algorytmów. Z tego powodu przy limicie owych odwo³añ w kryterium drugim, wyniki otrzymane przez algorytm genetyczny okaza³y siê lepsze. Wartym wspomnienia jest tak¿e to, i¿ w analizowanym przyk³adzie wyniki uzyskane przez metodê optymalizacji rojem cz¹stek s¹ nie tylko gorsze od wyników uzyskanych przez algorytm genetyczny lecz tak¿e przez symulowane wy¿arzanie, które to uzyska³o drugi rezultat dla ka¿dego badanego parametru maksymalnej liczby odwo³añ do funkcji testowej.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{col_all_2.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Colville'a - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:col_all_2}
\end{table}

\subsubsection{Funkcja Ackleya}

Kolejn¹ funkcj¹, która poddana zosta³a testom by³a funkcja Ackleya, dla której algorytm genetyczny oraz metoda optymalizacji rojem cz¹stek dla kryterium czasowego uzyska³a najlepsze rezultaty dla wielkoœci populacji oraz roju wynosz¹cej 50. Wyniki te (tabela \ref{tab:ack_ga_1} oraz \ref{tab:ack_pso_1}) zestawione zosta³y w tabeli \ref{tab:ack_all_1} z wynikami otrzymanymi przez algorytm symulowanego wy¿arzania. Z podsumowania tego jednoznacznie wynika, i¿ dla ka¿dego badanego parametru maksymalnego czasu, algorytm genetyczny zwróci³ najlepsze rezultaty, które to s¹ bardzo zbli¿one do minimum globalnego wynosz¹cego 0. Pozosta³e algorytmy nawet nie zbli¿y³y siê do tych rezultatów i utknê³y w minimach lokalnych funkcji.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ack_ga_1.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Ackleya - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ack_ga_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ack_pso_1.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Ackleya - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ack_pso_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ack_all_1.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Ackleya - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ack_all_1}
\end{table}

Wyniki dotycz¹ce kryterium limitu odwo³añ do funkcji testowej s¹ analogiczne jak w przypadku pierwszego kryterium. Jedyn¹ ró¿nic¹ s¹ wielkoœci populacji oraz roju, których wyniki zosta³y wziête do testu podsumowuj¹cego widocznego w tabeli \ref{tab:ack_all_2}. Funkcja Ackleya jest pierwsz¹ testowan¹ funkcj¹, do której minimum globalnego w obu badanych kryteriach zbli¿y³ siê tylko jeden porównywany algorytm metaheurystyczny - algorytm genetyczny.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ack_ga_2.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Ackleya - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ack_ga_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ack_pso_2.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Ackleya - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ack_pso_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ack_all_2.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Ackleya - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ack_all_2}
\end{table}

\subsubsection{Funkcja Rosenbrocka}

Funkcja Rosenbrocka jest pierwsz¹ funkcj¹, w której analizuj¹c ustalone kryterium, najlepsze otrzymane rezultaty nie nale¿¹ do jednego algorytmu heurystycznego. Po wyborze optymalnych wielkoœci populacji oraz roju dla kryterium czasowego, których wyniki testów dostêpne s¹ do wgl¹du w tabeli \ref{tab:ros_ga_1} oraz \ref{tab:ros_pso_1}, dokonano zestawienia najlepszych rezultatów wszystkich trzech algorytmów w tabeli \ref{tab:ros_all_1}. Wynika z niej, i¿ dla wartoœci maksymalnego czasu od 1 do 3 sekund, najlepsze rezultaty uzyska³a metoda optymalizacji rojem cz¹stek, podczas gdy dla wy¿szych z zakresu 4 do 6 sekund - algorytm genetyczny.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ros_ga_1.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Rosenbrocka - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ros_ga_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ros_pso_1.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Rosenbrocka - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ros_pso_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ros_all_1.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Rosenbrocka - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ros_all_1}
\end{table}

Dla drugiego analizowanego kryterium dotycz¹cego ustalonej maksymalnej liczby odwo³añ do funkcji testowej, rezultaty, które dostêpne s¹ do wgl¹du w tabeli \ref{tab:ros_all_2} okaza³y siê ju¿ bardziej jednolite. Algorytm genetyczny dla wielkoœci populacji równej 50 (tabela \ref{tab:ros_ga_2}) osi¹gn¹³ lepsze rezultaty od metody optymalizacji rojem cz¹stek z wielkoœci¹ roju równ¹ 10 (tabela \ref{tab:ros_pso_2}) dla ka¿dego przeprowadzonego testu.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ros_ga_2.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Rosenbrocka - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ros_ga_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ros_pso_2.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Rosenbrocka - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ros_pso_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{ros_all_2.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Rosenbrocka - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:ros_all_2}
\end{table}

\subsubsection{Funkcja Eggholdera}

Czwart¹ z kolei funkcj¹ jest funkcja Eggholdera, dla której rezultaty testów weryfikuj¹cych optymaln¹ wartoœæ populacji oraz roju zaprezentowane zosta³y na wykresach \ref{tab:egg_ga_1} oraz \ref{tab:egg_pso_1}. Dla obu algorytmów w kontekœcie testów dotycz¹cych kryterium maksymalnego czasu, wartoœci te zosta³y ustalone na poziomie 100. Ich rezultaty, wraz z rezultatami otrzymanymi dla algorytmu symulowanego wy¿arzania zgrupowane zosta³y na wykresie \ref{tab:egg_all_1}. Analizuj¹c wykres mo¿na dostrzec, i¿ metoda optymalizacji rojem cz¹stek poradzi³a sobie najlepiej, oscyluj¹c bardzo blisko minimum globalnego funkcji Eggholdera, które wynosi $-959,6407$. Tu¿ za rojem cz¹stek uplasowa³ siê algorytm genetyczny, którego rezultaty osi¹ga³y œrednio wartoœæ blisk¹ wartoœci $-900$. Wynik ten jest wci¹¿ du¿o lepszy od wyników zwróconych przez algorytm symulowanego wy¿arzania, który zatrzymywa³ siê na poziomie wartoœci oko³o $-500$.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{egg_ga_1.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Eggholdera - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:egg_ga_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{egg_pso_1.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Eggholdera - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:egg_pso_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{egg_all_1.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Eggholdera - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:egg_all_1}
\end{table}

Przechodz¹c do drugiego analizowanego kryterium - maksymalnej liczby odwo³añ do funkcji - mo¿na zaobserwowaæ, i¿ wyniki s¹ bardzo zbli¿one do wyników otrzymanych w kryterium pierwszym. Testy badaj¹ce optymaln¹ wielkoœæ populacji dla algorytmu genetycznego oraz wielkoœci roju dla metody optymalizacji rojem cz¹stek dostêpne s¹ do wgl¹du na wykresie \ref{tab:egg_ga_2} oraz \ref{tab:egg_pso_2}, natomiast testy porównuj¹ce wszystkie trzy badane algorytmy heurystyczne na wykresie \ref{tab:egg_all_2}. 

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{egg_ga_2.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Eggholdera - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:egg_ga_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{egg_pso_2.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Eggholdera - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:egg_pso_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[height=1\textwidth]{egg_all_2.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Eggholdera - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:egg_all_2}
\end{table}

\subsubsection{Funkcja Griewanka}

Ostatni¹ u¿yt¹ funkcj¹ testow¹ by³a funkcja Griewanka, dla której podobnie jak w przypadku funkcji Rosenbrocka rezultaty otrzymane dla kryterium maksymalnego czasu nie s¹ jednoznaczne. Porównuj¹c najlepsze wyniki otrzymane dla algorytmu genetycznego z tabeli \ref{tab:gri_ga_1} oraz dla metody optymalizacji rojem cz¹stek z tabeli \ref{tab:gri_pso_1} z wynikami otrzymanymi przez algorytm symulowanego wy¿arzania, mo¿na dostrzec w tabeli \ref{tab:gri_all_1}, i¿ lepszy rezultat otrzymany w teœcie 1 oraz 3 sekund nale¿y do algorytmu genetycznego, a dla pozosta³ych wartoœci maksymalnego czasu dla metody optymalizacji rojem cz¹stek. Otrzymane przez algorytm genetyczny oraz metodê roju cz¹stek rezultaty s¹ jednak bardzo do siebie zbli¿one i nie mog¹ jednoznacznie wyznaczyæ najlepszego algorytmu. 

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{gri_ga_1.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Griewanka - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:gri_ga_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{gri_pso_1.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Griewanka - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:gri_pso_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{gri_all_1.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Griewanka - kryterium czasowe, Ÿród³o: Opracowanie w³asne.}
    \label{tab:gri_all_1}
\end{table}

Drugie kryterium, pod k¹tem którego przeprowadzone zosta³y testy wskazuje ju¿ jednak w tabeli \ref{tab:gri_all_2} jednoznacznie, i¿ lepsze rezultaty uzyska³ algorytm genetyczny. Ponad dwukrotnie wiêksza liczba odwo³añ metody optymalizacji rojem cz¹stek do funkcji testowej w pierwszym kryterium, w kryterium drugim zosta³a zrównana. W tym przypadku przy takiej samej liczbie obliczeñ wartoœci funkcji testowej, algorytm genetyczny uzyska³ wyniki bli¿sze minimum globalnemu ni¿ metoda optymalizacji rojem cz¹stek. Algorytm symulowanego wy¿arzania w testach dotycz¹cych obu kryteriów odniós³ najgorsze rezultaty ze wszystkich porównywanych algorytmów heurystycznych. Warto jednak nadmieniæ, i¿ wyniki przez niego uzyskane oscylowa³y równie¿ blisko minimum globalnego.

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{gri_ga_2.png}
    \caption{Zestawienie wyników algorytmu genetycznego dla funkcji Griewanka - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:gri_ga_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{gri_pso_2.png}
    \caption{Zestawienie wyników metody optymalizacji rojem cz¹stek dla funkcji Griewanka - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:gri_pso_2}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{gri_all_2.png}
    \caption{Zestawienie najlepszych wyników wszystkich trzech porównywanych algorytmów metaheurystycznych dla funkcji Griewanka - kryterium liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:gri_all_2}
\end{table}

\subsection{Wnioski z przeprowadzonych doœwiadczeñ}

Przeprowadzone doœwiadczenia wykonane zosta³y z myœl¹ o wyrównaniu szans ka¿dego z badanych algorytmów heurystycznych. Metody porównawcze opisane w \ref{dzial:MetodyPorownawczeWybranychAlgorytmow} umo¿liwi³y na podstawie ustalonych kryteriów, jednakowych dla wszystkich algorytmów, sprawdziæ rezultaty przez nie uzyskane. Przez fakt ró¿n¹ specyfikê algorytmów oraz posiadanie przez nich ró¿nych parametrów, czasoch³onn¹ kwesti¹ okaza³a siê próba ich wyskalowania. 
Podsumowuj¹c przeprowadzone doœwiadczenia w kontekœcie kryterium ustalonego czasu pracy, w obrêbie którego algorytm za zadanie mia³ znaleŸæ najmniejsz¹ wartoœæ badanej funkcji, algorytm genetyczny w jednej na szeœæ funkcji testowych - funkcji Ackleya - uzyska³ najlepszy rezultat dla ka¿dej wartoœci maksymalnego czasu. W dwóch kolejnych funkcjach - Rosenbrocka oraz Griewanka - uzyska³ najlepszy wynik dla kolejno trzech z szeœciu oraz czterech z szeœciu wartoœci parametru. Funkcja Bohachevsky'ego I, Colville'a oraz Eggholdera by³y funkcjami w której algorytm genetyczny uplasowa³ siê na drugim miejscu, za metod¹ optymalizacji rojem cz¹stek, która zwróci³a najlepsze wyniki. 
Metoda ta uzyska³a równie¿ najlepsze rezultaty dla trzech z szeœciu oraz dwóch z szeœciu parametrów dla funkcji Rosenbrocka oraz Griewanka. Najgorzej w zestawieniu wypad³ algorytm symulowanego wy¿arzania, który dla ka¿dej funkcji testowej ulokowa³ siê na miejscu trzecim. Algorytm ten, choæ zwraca³ wyniki bliskie minimum globalnemu, by³y one gorsze od rezultatów zwróconych przez algorytm genetyczny oraz metodê optymalizacji rojem cz¹stek.

Przy analizie wyników dotycz¹cych próby czasowej, zauwa¿alna by³a ró¿nica w iloœci wyliczeñ funkcji testowej dokonywana przez porównywane algorytmy. Metoda optymalizacji rojem cz¹stek odwo³ywa³a siê do funkcji testowych œrednio $2,59$ razy wiêcej ni¿ algorytm genetyczny oraz $25.58$ razy wiêcej ni¿ algorytm symulowanego wy¿arzania. Ró¿nice te zosta³y zrównane w wynikach testów odnosz¹cych siê do drugiego kryterium porównawczego jakim by³a ustalona maksymalna liczba odwo³añ do funkcji testowej.

Przy za³o¿eniu jednakowej liczby odwo³añ do funkcji testowych, klasyfikacja algorytmów uleg³a du¿emu przetasowaniu w porównaniu do kryterium pierwszego. Bez zmiany wyników zachowa³y siê wszystkie testowane funkcje dwuwymiarowe - Bohachevsky'ego I oraz Eggholdera, w której metoda optymalizacji rojem cz¹stek uplasowa³a siê przed algorytmem genetycznym oraz algorytmem symulowanego wy¿arzenia. W pozosta³ych czterech funkcjach najlepsze rezultaty uzyska³ algorytm genetyczny, który dla funkcji Rosenbrocka oraz Griewanka zaj¹³ pierwsze miejsce przed metod¹ optymalizacji rojem cz¹stek oraz symulowanym wy¿arzaniem. Ciekawe wyniki dostarczy³a funkcja Colville'a, dla której w pierwszym kryterium najlepsze wyniki uzyska³a metoda optymalizacji rojem cz¹stek. W drugim kryterium osi¹gnê³a ona najgorszy rezultat, plasuj¹c siê za algorytmem symulowanego wy¿arzania, który dla funkcji Colville'a oraz Ackleya uzyska³ wyniki pozwalaj¹ce umiejscowiæ go na drugiej pozycji.

Ranking algorytmów odnosz¹cy siê do wyników przeprowadzonych testów dla kryterium czasowego oraz kryterium maksymalnej liczby odwo³añ do funkcji testowej za³¹czone zosta³y do wgl¹du w tabeli \ref{tab:results_1} oraz \ref{tab:results_2}

\begin{table}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{results_1.png}
    \caption{Ranking porównanych algorytmów heurystycznych (Algorytm genetyczny - GA; Metoda optymalizacji rojem cz¹stek - PSO; Algorytm symulowanego wy¿arzania - SA) dla wyników dotycz¹cych kryterium maksymalnego czasu, Ÿród³o: Opracowanie w³asne.}
    \label{tab:results_1}
\end{table}

\begin{table}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{results_2.png}
    \caption{Ranking porównanych algorytmów heurystycznych (Algorytm genetyczny - GA; Metoda optymalizacji rojem cz¹stek - PSO; Algorytm symulowanego wy¿arzania - SA) dla wyników dotycz¹cych maksymalnej liczby odwo³añ do funkcji testowej, Ÿród³o: Opracowanie w³asne.}
    \label{tab:results_2}
\end{table}

\section{Podsumowanie}

Celem prezentowanej pracy magisterskiej by³o dokonanie analizy porównawczej algorytmu symulowanego wy¿arzania, algorytmu genetycznego oraz metody optymalizacji rojem cz¹stek przy pomocy dedykowanej aplikacji bazodanowej umo¿liwiaj¹cej zautomatyzowanie procesu szukania minimum globalnego dla zadanych funkcji testowych.
Przedstawiony cel zosta³ zrealizowany, czego efektem jest dzia³aj¹ca aplikacja bazodanowa, która umo¿liwi³a przeprowadzenie licznych testów zadanych algorytmów heurystycznych, których zagregowane wyniki umo¿liwi³y ich porównanie.

Zastosowanie œrodowiska bazodanowego umo¿liwi³o bardzo szybkie zapisywanie du¿ych iloœci danych dostarczanych z zaimplementowanej aplikacji, a nastêpnie ich agregacjê wed³ug uznanych kryteriów. Agregacja ta dziêki jêzykowi zapytañ SQL by³a bardzo efektywna przez fakt du¿ej dowolnoœci w kontekœcie sposobu jej wykonania. Mo¿liwe by³o pogrupowanie wszystkich otrzymanych wyników, bazuj¹c na dowolnym zapisywanym w bazie danych parametrze, co umo¿liwi³o przeprowadzenie operacji dostrojenia algorytmów oraz ich porównania pod k¹tem ustalonych dwóch kryteriów porównawczych. Dziêki obecnoœci bazy danych mo¿liwe by³o równie¿ przechowanie wyników wszystkich testów, co pozwoli³o na ich analizê w dowolnym momencie czasu bez obawy o ich utratê i koniecznoœæ ponownego wykonania czasoch³onnych testów.

W fazie implementacji za³o¿onych modu³ów aplikacji bazodanowej napotkano na kilka problemów dotycz¹cych zmiany wymagañ projektowych, sposobu realizacji ustalonych funkcji oraz integracji systemów. Zmiany te dotyczy³y g³ównie technicznych aspektów dotycz¹cych sposobu implementacji aplikacji bazodanowej oraz zmiany podejœcia co do liczby wymiarów obs³ugiwanych funkcji testowych. Wraz z biegiem czasu powstawa³y nowe pomys³y, które dotyczy³y usprawnienia istniej¹cych rozwi¹zañ, które nie zawsze jednak mog³y byæ wprowadzone przez pryzmat czasu którego to wymaga³y do ich implementacji, przetestowania oraz po³¹czenia z istniej¹cym ju¿ systemem. Powstaj¹ce propozycje zmian wi¹za³y siê tak¿e z modyfikacj¹ istniej¹cej architektury systemu, co w znacznym stopniu zmienia³oby zaplanowany wczeœniej harmonogram prac i wyd³u¿a³oby finalne ukoñczenie projektu. 

Pomimo tych elementów utworzona aplikacja, sposób jej po³¹czenia ze œrodowiskiem obliczeniowym Matlab oraz œrodowiskiem bazodanowym MS-SQL umo¿liwi³ osi¹gniêcie celów zadanych w prezentowanej pracy magisterskiej, czego efektem s¹ wyniki testów które namacalnie prezentuj¹ uzyskane rezultaty otrzymane przez porównywane algorytmy metaheurystyczne.

\begin{thebibliography}{12}

\bibitem{ProblemKomiwojazera}
Michalewicz Z., Fogel D.B.: \textsl{Jak to rozwi¹zaæ czyli nowoczesna heurystyka}, Wydawnictwa Naukowo-Techniczne, Warszawa, 2006, str. 225-228

\bibitem{TestFunctionsForOpt}
Molga M., Smutnicki C.,\textsl{Test functions for optimization needs}, 2005, http://www.zsd.ict.pwr.wroc.pl/files/docs/functions.pdf 
\newline
[dostêp 1.05.2017r. - 15.07.2017r.]

\bibitem{RankingFunkcjiTestowych}
http://infinity77.net/global\_optimization/test\_functions.html
\newline 
[dostêp 1.06.2017r. - 26.08.2017r.]

\bibitem{DolinaRosenbrocka}
Castillo O., Melin P.: \textsl{Soft Computing and Fractal Theory for Intelligent Manufacturing}, Physica-Verlag, Heidelberg, 2003, str. 100-101

\bibitem{HeurystykaZGreki}
Nola R., Sankey H.: \textsl{Theories of Scientific Method}, Routledge, Nowy Jork, 2007, str. 25-28

\bibitem{HeurystykaWyzszegoPoziomu}
Rocha A., Correia A., Adeli H., Reis L., Costanzo S., \textsl{Recent Advances in Information Systems and Technologies Volume 2}, Springer, 2017, str. 76

\bibitem{PSOOgolneInfo}
http://zsi.ii.us.edu.pl/\textasciitilde mboryczka/IntStad/pso\_informacje.php
\newline
[dostêp 20.06.2017r. - 26.08.2017r.]

\bibitem{PSOWzory}
Foryœ P., \textsl{Zastosowanie metody roju cz¹stek w optymalnym projektowaniu elementów konstrukcji}, Wydawnictwo Politechniki Krakowskiej, 4-M/2008, str. 32-33

\bibitem{GetnetycznyPoRazPierwszy}
Holland J. H.: \textsl{Adaptation in Natural and Artificial Systems}, Univ. of Michigan Press, Ann Arbor, 1975

\bibitem{GenetycznyTerminologia}
Deppa S. N.: \textsl{Introduction to Genetic Algorithms}, Springer-Verlag, Heidelberg, 2008, str. 5

\bibitem{GenetycznyKodowanieBinarne}
Ibidem, str. 43-44

\bibitem{GenetycznyRuletka}
Ibidem, str. 47-48.

\bibitem{Hejlsberg}
Hejlsberg A., Torgersen M. Wilthamuth S., Golde P.: \textsl{The C\# Programming Language}, Addison-Wesley, Massachusetts, 2009, str. 12-14

\bibitem{CSharpAdvantages}
http://urriellu.net/en/articles-software/csharp-advantages.html 
\newline 
[dostêp 22.08.2017r. - 23.08.2017r.]

\bibitem {WPF}
 Nathan  A.: \textsl{WPF 4.5. Ksiêga eksperta}, Helion, Gliwice, 2015
 
\bibitem{Xml}
http://www.w3schools.com/xml/xml\_whatis.asp

\bibitem {T-SQL}
 Itzik B.:  \textsl{Microsoft SQL Server 2012. Podstawy jêzyka T-SQL}, Helion, Gliwice, 2012
 
\bibitem{bookVS}
Matulewski J.: \textsl{Visual Studio 2013. Podrêcznik programowania w C\# z zadaniami}, Helion, Gliwice, 2014 

\bibitem{ResharperFeatures} https://www.jetbrains.com/resharper/features/ 
\newline 
[dostêp 1.08.2017r. - 23.08.2017r.]

\bibitem{FazyProdukcjiOpr} 
Jaszkiewicz A.: \textsl{In¿ynieria oprogramowania}, Helion, 1997

\bibitem{MvvmOpis} 
Petzold C.: \textsl{Windows 8. Programowanie aplikacji z wykorzystaniem C\# i XAML}, Helion, Gliwice, 2013, str. 215-235

\bibitem{WpfBinding}
MacDonald M.: \textsl{Pro WPF 4.5 in VB: Windows Presentation Foundation in .NET 4.5}, Apress, 2012, str. 227-242

\bibitem{WpfCommands}
Ibidem, str. 243-268.

\bibitem{DependencyInjection}
Seemann M.: \textsl{Dependency Injection in .NET}, Manning Publications Co., Nowy Jork, 2012

\bibitem{PrzypisyCodeFirst}
https://msdn.microsoft.com/en-us/data/jj591583 
\newline 
[dostêp 1.08.2017r. - 23.08.2017r.]

\bibitem{MetodyPorownawczeDoc}
Silberholz, J., Golden, B., \textsl{Comparison of metaheuristics}, Handbook of Metaheuristics, 2nd edn, Springer, Heidelberg, 2010


\end{thebibliography}

\makeatletter
\def\@tocrmarg{2.55em plus 3em}
\listoffigures

\listoftables

\lstlistoflistings
\end{document}